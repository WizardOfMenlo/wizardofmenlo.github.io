<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Doing mixed matrix commitments (MMCS) with STIR & WHIR | Giacomo's Blog</title><meta name=keywords content="hashes,concrete,theory"><meta name=description content="Domain shifting to the rescue"><meta name=author content="Giacomo Fenzi"><link rel=canonical href=https://wizardofmenlo.github.io/blurbs/mmcs-stir-whir/><link crossorigin=anonymous href=/assets/css/stylesheet.5c3d2aa85a103c2d32fb4f6cbe26e29098f291f6fedf6b1d5b502c91573ae1ce.css integrity="sha256-XD0qqFoQPC0y+09svibikJjykfb+32sdW1AskVc64c4=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Doing mixed matrix commitments (MMCS) with STIR & WHIR"><meta property="og:description" content="Domain shifting to the rescue"><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/blurbs/mmcs-stir-whir/"><meta property="article:section" content="blurbs"><meta property="article:published_time" content="2024-10-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Doing mixed matrix commitments (MMCS) with STIR & WHIR"><meta name=twitter:description content="Domain shifting to the rescue"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blurbs","item":"https://wizardofmenlo.github.io/blurbs/"},{"@type":"ListItem","position":2,"name":"Doing mixed matrix commitments (MMCS) with STIR \u0026 WHIR","item":"https://wizardofmenlo.github.io/blurbs/mmcs-stir-whir/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Doing mixed matrix commitments (MMCS) with STIR \u0026 WHIR","name":"Doing mixed matrix commitments (MMCS) with STIR \u0026 WHIR","description":"Domain shifting to the rescue","keywords":["hashes","concrete","theory"],"articleBody":"This post looks at Plonky3 and combining Mixed Matrix Commitment Schemes with STIR ü•£ and WHIR üå™Ô∏è as the low-degree test.\nAs far as I understand, the problem that we are aiming to solve is the following: The prover has committed to a matrix of functions (note the possibly different number of columns in each row) $$ \\begin{bmatrix} f_{1, 1}, \\dots, f_{1, n_1} \\\\ \\vdots \\\\ f_{m, 1}, \\dots, f_{m, n_m} \\end{bmatrix} $$\nwhere $f_{i, j}: \\mathcal{L}_i \\to \\mathbb{F}$ for a list of domains $\\mathcal{L}_1, \\dots, \\mathcal{L}_m \\subseteq \\mathbb{F}$.1\nThe prover wants to show that each $f_{i, j} \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}_i, d/2^{i-1}]$.\nSuppose that we want to run an iteration of STIR or WHIR to check this. An important parameter to keep in mind here is the folding factor $k$, typically $4$.2 A STIR or WHIR iteration at each step reduces testing that $f \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]$ to testing that $f‚Äô \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}‚Äô, d/2^k]$3.\nDenote by $\\mathcal{L}^{(1)} = \\mathcal{L}_1, \\mathcal{L}^{(2)}, ‚Ä¶, \\mathcal{L}^{(M)}$ the domains appearing in the STIR iteration4.\nEasy case The easy case is the one in which $\\mathcal{L}_1, ‚Ä¶, \\mathcal{L}_k = \\mathcal{L}^{(1)}$, $\\mathcal{L}_{k+1}, ‚Ä¶, \\mathcal{L}_{2k} = \\mathcal{L}^{(2)}$ and so on. In this case, the committer is aware of what STIR will do, and it choses the domain to simplify the accumulation.\nIn the first iteration, the prover simply tests a random linear combination of $$ \\sum_{j \\in [n_1]} \\epsilon_1^{j - 1} f_{1, j} + \\epsilon_1^{n_1} \\cdot \\sum_{j \\in [n_2]} \\epsilon_1^{j - 1} \\mathsf{Cor}(f_{2, j}, d) + \\dots + \\epsilon_i^{n_k} \\cdot \\sum_{j \\in [n_k]} \\epsilon_1^{j - 1} \\mathsf{Cor}(f_{k, j}, d)$$ ($\\mathsf{Cor}(f, d)$ is just some notation for degree correction up to degree $d$ as in the STIR paper.) This will define a new virtual function $g^{(1)}: \\mathcal{L}^{(2)} \\to \\mathbb{F}$ to be tested.\nIn the next round, the prover instead of just testing $g^{(1)}$, it will test instead\n$$g^{(1)} + \\epsilon_2 \\cdot \\left( \\sum_{j \\in [n_{k+1}]} \\epsilon_2^{j - 1} f_{k+1, j} + \\dots + \\epsilon_2^{n_{2k}} \\cdot \\sum_{j \\in [n_{2k}]} \\epsilon_2^{j - 1} \\mathsf{Cor}(f_{2k, j}, d/2^k) \\right)$$ and so on.\nSoundness follows quite easily, if any of the functions do not satisfy the proximity claim, the sum will be far from low-degree by proximity gaps.\nHarder case In the harder case, there is no relation between the domains that STIR chooses and the ones that the MMCS has committed to. To solve this, we have to do a domain shift. Conveniently, STIR is exactly a protocol for doing domain shifts.\nThe prover first does a STIR iteration on $$ \\sum_{j \\in [n_1]} \\epsilon_1^{j - 1} f_{1, j} $$ which defines a function $g^{(1, 1)}: \\mathcal{L}^{(2)} \\to \\mathbb{F}$. Then, it does a STIR iteration with folding factor $k - 1$5 on $$ \\sum_{j \\in [n_2]} \\epsilon_1^{j - 1} f_{2, j} $$ which defines a function $g^{(1, 2)}: \\mathcal{L}^{(2)} \\to \\mathbb{F}$ and so on. At the end you will have $k$ functions $g^{(1, 1)}, \\dots, g^{(1, k)}$ over the same domain $\\mathcal{L}^{(2)}$.\nThen, first run a STIR iteration on a random linear combination of these functions (obtaining a new function $g^{(2, 0)}: \\mathcal{L}^{(3)} \\to \\mathbb{F}$). Then, do $k$ STIR iteration as above on each row of the matrix, obtaining new functions $ g^{(2, 1)}, \\dots, g^{(2, k)}: \\mathcal{L}^{(3)} \\to \\mathbb{F}$.\nIterating the protocol yields a low-degree test for MMCS. Soundness should follow as above. Of course, if at any point the domains match one can use the same strategy as in the easier case to efficiently reduce the number of running accumulators.\nI am assuming that each row has the same domain, this can be generalized but it involves adding an extra index so I will not.¬†‚Ü©Ô∏é\nI am using WHIR‚Äôs folding factor convention, i.e. each iteration will reduce the degree by $2^k$.¬†‚Ü©Ô∏é\nWHIR in fact reduces it to a test for constrained RS codes i.e. that $f‚Äô \\in \\mathsf{CRS}[\\mathbb{F}, \\mathcal{L}‚Äô, d/2^k, \\hat{w}‚Äô, \\sigma‚Äô]$, but will ignore this distinction. I have to think it WHIR natively supports this or some more work is needed.¬†‚Ü©Ô∏é\nRemember that these domains can also be chosen freely, see this .¬†‚Ü©Ô∏é\nAlternatively, one can use the same folding parameter and then degree correct the resulting function.¬†‚Ü©Ô∏é\n","wordCount":"690","inLanguage":"en","datePublished":"2024-10-15T00:00:00Z","dateModified":"2024-10-15T00:00:00Z","author":{"@type":"Person","name":"Giacomo Fenzi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/blurbs/mmcs-stir-whir/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Doing mixed matrix commitments (MMCS) with STIR & WHIR</h1><div class=post-meta><span title='2024-10-15 00:00:00 +0000 UTC'>October 2024</span>&nbsp;&#183;&nbsp;Giacomo Fenzi&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2024/390 rel="noopener noreferrer" target=_blank>ePrint: 2024/390</a></div></header><div class=post-content><p>This post looks at <a href=https://github.com/Plonky3/Plonky3 target=_blank>Plonky3</a>
and combining Mixed Matrix Commitment Schemes with <a href=/papers/stir>STIR ü•£</a>
and <a href=/papers/whir>WHIR üå™Ô∏è</a>
as the low-degree test.</p><p>As far as I understand, the problem that we are aiming to solve is the following:
The prover has committed to a matrix of functions (note the possibly different number of columns in each row)
$$
\begin{bmatrix} f_{1, 1}, \dots, f_{1, n_1} \\ \vdots \\ f_{m, 1}, \dots, f_{m, n_m} \end{bmatrix}
$$</p><p>where $f_{i, j}: \mathcal{L}_i \to \mathbb{F}$ for a list of domains $\mathcal{L}_1, \dots, \mathcal{L}_m \subseteq \mathbb{F}$.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>The prover wants to show that each $f_{i, j} \in \mathsf{RS}[\mathbb{F}, \mathcal{L}_i, d/2^{i-1}]$.</p><p>Suppose that we want to run an iteration of STIR or WHIR to check this. An important parameter to keep in mind here is the folding factor $k$, typically $4$.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>
A STIR or WHIR iteration at each step reduces testing that $f \in \mathsf{RS}[\mathbb{F}, \mathcal{L}, d]$ to testing that $f&rsquo; \in \mathsf{RS}[\mathbb{F}, \mathcal{L}&rsquo;, d/2^k]$<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>Denote by $\mathcal{L}^{(1)} = \mathcal{L}_1, \mathcal{L}^{(2)}, &mldr;, \mathcal{L}^{(M)}$ the domains appearing in the STIR iteration<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><h2 id=easy-case>Easy case</h2><p>The easy case is the one in which $\mathcal{L}_1, &mldr;, \mathcal{L}_k = \mathcal{L}^{(1)}$,
$\mathcal{L}_{k+1}, &mldr;, \mathcal{L}_{2k} = \mathcal{L}^{(2)}$ and so on. In this case, the committer is aware of what STIR will do, and it choses the domain to simplify the accumulation.</p><p>In the first iteration, the prover simply tests a random linear combination of
$$ \sum_{j \in [n_1]} \epsilon_1^{j - 1} f_{1, j} + \epsilon_1^{n_1} \cdot \sum_{j \in [n_2]} \epsilon_1^{j - 1} \mathsf{Cor}(f_{2, j}, d) + \dots + \epsilon_i^{n_k} \cdot \sum_{j \in [n_k]} \epsilon_1^{j - 1} \mathsf{Cor}(f_{k, j}, d)$$
($\mathsf{Cor}(f, d)$ is just some notation for degree correction up to degree $d$ as in the STIR paper.)
This will define a new virtual function $g^{(1)}: \mathcal{L}^{(2)} \to \mathbb{F}$ to be tested.</p><p>In the next round, the prover instead of just testing $g^{(1)}$, it will test instead</p><p>$$g^{(1)} + \epsilon_2 \cdot \left( \sum_{j \in [n_{k+1}]} \epsilon_2^{j - 1} f_{k+1, j} + \dots + \epsilon_2^{n_{2k}} \cdot \sum_{j \in [n_{2k}]} \epsilon_2^{j - 1} \mathsf{Cor}(f_{2k, j}, d/2^k) \right)$$
and so on.</p><p>Soundness follows quite easily, if any of the functions do not satisfy the proximity claim, the sum will be far from low-degree by proximity gaps.</p><h2 id=harder-case>Harder case</h2><p>In the harder case, there is no relation between the domains that STIR chooses and the ones that the MMCS has committed to. To solve this, we have to do a domain shift. Conveniently, STIR is exactly a protocol for doing domain shifts.</p><p>The prover first does a STIR iteration on
$$ \sum_{j \in [n_1]} \epsilon_1^{j - 1} f_{1, j} $$
which defines a function $g^{(1, 1)}: \mathcal{L}^{(2)} \to \mathbb{F}$.
Then, it does a STIR iteration with folding factor $k - 1$<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> on
$$ \sum_{j \in [n_2]} \epsilon_1^{j - 1} f_{2, j} $$
which defines a function $g^{(1, 2)}: \mathcal{L}^{(2)} \to \mathbb{F}$ and so on.
At the end you will have $k$ functions $g^{(1, 1)}, \dots, g^{(1, k)}$ over the same domain $\mathcal{L}^{(2)}$.</p><p>Then, first run a STIR iteration on a random linear combination of these functions (obtaining a new function $g^{(2, 0)}: \mathcal{L}^{(3)} \to \mathbb{F}$). Then, do $k$ STIR iteration as above on each row of the matrix, obtaining new functions $
g^{(2, 1)}, \dots, g^{(2, k)}: \mathcal{L}^{(3)} \to \mathbb{F}$.</p><p>Iterating the protocol yields a low-degree test for MMCS. Soundness should follow as above. Of course, if at any point the domains match one can use the same strategy as in the easier case to efficiently reduce the number of running accumulators.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I am assuming that each row has the same domain, this can be generalized but it involves adding an extra index so I will not.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>I am using WHIR&rsquo;s folding factor convention, i.e. each iteration will reduce the degree by $2^k$.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>WHIR in fact reduces it to a test for constrained RS codes i.e. that $f&rsquo; \in \mathsf{CRS}[\mathbb{F}, \mathcal{L}&rsquo;, d/2^k, \hat{w}&rsquo;, \sigma&rsquo;]$, but will ignore this distinction. I have to think it WHIR natively supports this or some more work is needed.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Remember that these domains can also be chosen freely, see <a href=/blurbs/stir-parameters>this</a>
.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Alternatively, one can use the same folding parameter and then degree correct the resulting function.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/hashes/>hashes</a></li><li><a href=https://wizardofmenlo.github.io/tags/concrete/>concrete</a></li><li><a href=https://wizardofmenlo.github.io/tags/theory/>theory</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>