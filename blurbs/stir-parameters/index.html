<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STIR: Setting Parameters | Giacomo's Blog</title><meta name=keywords content="hashes,concrete,theory"><meta name=description content="STIR has a few more parameters to tweak compared to FRI. Here we mention a few and how they impact the concrete performance of the scheme."><meta name=author content="Giacomo Fenzi"><link rel=canonical href=https://wizardofmenlo.github.io/blurbs/stir-parameters/><link crossorigin=anonymous href=/assets/css/stylesheet.5c3d2aa85a103c2d32fb4f6cbe26e29098f291f6fedf6b1d5b502c91573ae1ce.css integrity="sha256-XD0qqFoQPC0y+09svibikJjykfb+32sdW1AskVc64c4=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="STIR: Setting Parameters"><meta property="og:description" content="STIR has a few more parameters to tweak compared to FRI. Here we mention a few and how they impact the concrete performance of the scheme."><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/blurbs/stir-parameters/"><meta property="article:section" content="blurbs"><meta property="article:published_time" content="2024-02-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="STIR: Setting Parameters"><meta name=twitter:description content="STIR has a few more parameters to tweak compared to FRI. Here we mention a few and how they impact the concrete performance of the scheme."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blurbs","item":"https://wizardofmenlo.github.io/blurbs/"},{"@type":"ListItem","position":2,"name":"STIR: Setting Parameters","item":"https://wizardofmenlo.github.io/blurbs/stir-parameters/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STIR: Setting Parameters","name":"STIR: Setting Parameters","description":"STIR has a few more parameters to tweak compared to FRI. Here we mention a few and how they impact the concrete performance of the scheme.","keywords":["hashes","concrete","theory"],"articleBody":"Our recent work, STIR ü•£ (See 2024/390 and blog-post. ) is an IOPP for RS codes with improved query complexity compared to the state-of-the art, FRI. Compared to FRI, STIR has a few more parameters that one can tweak, which can have a rather large impact on prover time, verifier time and argument size. This short blurb details what these parameters are, and how they translate, concretely, in the resulting argument. I won‚Äôt be completely formal here, details worked out are in Subsection 5.3, Section 6 and Appendix C of the STIR paper.\nParameters In this note, we focus on a single iteration of STIR. We assume that the following parameters are given:\nA security parameter$\\lambda \\in \\mathbb{N}$. The Reed-Solomon code being tested, this includes: A field $\\mathbb{F}$1. A smooth evaluation domain $\\mathcal{L} \\subseteq \\mathbb{F}$. A degree bound $d \\in \\mathbb{N}$. An initial rate $\\rho := \\frac{d}{|\\mathcal{L}|}$. We assume that the proximity bound to be tested from here on is $\\delta := 1 - \\rho$ (i.e. we are assuming the conjecture and ignoring $\\eta$.) If instead $\\delta$ is in unique decoding range, the protocol can be made simpler by removing the OOD samples. We do not discuss this here.\nA parametrization for a STIR iteration consists of the following:\nAn evaluation domain $\\mathcal{L}^\\star \\subseteq \\mathbb{F}$. A folding parameter $k$. The number of OOD-samples $s$. The number of queries $t$. The PoW bits $\\lambda_b$. We note that the parameters of each STIR iteration can be chosen independently.\nSetting parameters This is not the place to precisely tell people how to set the parameters for soundness to hold, that‚Äôs what the paper is for. Here I just want to give some intuition on how one would go about doing this. First, I suppose that you would pick evaluation domain $\\mathcal{L}^\\star$ and folding parameter $k$. Letting $c := \\frac{|\\mathcal{L}|}{|\\mathcal{L}^\\star|}$, note that the rate of the new code being tested is $\\rho^\\star := (c/k) \\cdot \\rho$. The key observation of STIR is that a lower rate makes testing easier, so the smaller the value $c/k$ is the fewer queries we require in latter iterations. In the paper, we set $c = 2$ to keep a linear proof length, but this is by no means necessary. You can even pick $c \u003c 1$. The tradeoff in chosing $\\mathcal{L}^\\star$ is that:\nLarge $\\mathcal{L}^\\star$ drives the rate down and thus the number of queries in the next iteration quicker. However, the prover is then less efficient (as an FFT over $\\mathcal{L}^\\star$ must be performed). Regarding the folding parameter $k$:\nA larger folding parameter $k$ reduces both the degree of the polynomial quicker and decreases the rate of the next iteration, also driving down the number of queris. On the other end, the verifier now needs to (at least) compute larger folds, each of which has cost at least linear in $k$, and also needs to read more field elements. Once those two parameters are set, the OOD-samples should be set so that they reach $\\lambda$ bits of security. In general, for most sane configurations $s = 1$ or $s = 2$ should suffice.\nFinally, $t$ and $\\lambda_b$ should be set so that $(1 - \\delta)^t \u003c 2^{\\lambda - \\lambda_b}$. Here there are also some tradeoffs:\nA larger value of $\\lambda_b$ drives down verifier time and argument size, at the cost of increased prover time. Further, larger $t$ not only increases the argument size but also the verifier running time, as it requires to compute more folds (and the virtual functions become more expensive to compute). Prover time Prover time in a STIR iteration is easy to estimate. We assume that the prover has access to the message $\\hat{f} \\in \\mathbb{F}[X]$ of degree $d$ for the codeword $f: \\mathcal{L} \\to \\mathbb{F}$ being tested. The STIR prover does the following:\nDerives $\\alpha \\in \\mathbb{F}$ by FS. Computes $\\hat{g} := \\mathsf{PolyFold}(\\hat{f}, \\alpha, k) \\in \\mathbb{F} $ of degree $d/k$. Evaluates $\\hat{g}$ on $\\mathcal{L}^\\star $ via a FFT to compute a vector of evaluations $g: \\mathcal{L}^\\star \\to \\mathbb{F}$. Commits to $g$ using a Merkle tree. Derives $x_1, \\dots, x_s \\in \\mathbb{F}$ by FS. Evaluates $g$ at $x_1, \\dots, x_s$ using Horner‚Äôs rule. Derives $v_1, \\dots, v_t \\in \\mathcal{L}^k$ by FS. Computes a new function $\\hat{f}^\\star \\in \\mathbb{F} $ of degree $d/k$ by quotienting $\\hat{g}$ at $s + t$ points, and degree correcting. All summed up, the prover does:\nSqueeze $1 + s + t$ elements out of the FS sponge. Computes $2 \\cdot |\\mathcal{L}^\\star|$ hashes for the Merkle commitment. Computes an FFT of size $|\\mathcal{L}^\\star|$ for polynomial of size $d/k$, resulting in $O(|\\mathcal{L}^\\star| \\cdot \\log d/k)$ fops. Does an additional $O(d)$ fops to compute the folds and $O(d/k)$ fops to compute the quotient and the degree correction. So the prover costs are: $$ (1 + s + t) \\cdot \\mathsf{FS} + 2 \\cdot |\\mathcal{L}^\\star| \\cdot \\mathsf{H} + \\mathsf{FFT}(\\mathcal{L}^\\star , d/k) + O(d + d/k) \\cdot \\mathbb{F} $$\nArgument size Argument size is also easy to estimate, it consists of:\nA single Merkle root (for $g: \\mathcal{L}^\\star \\to \\mathbb{F}$). $s$ elements of $\\mathbb{F}$ (for OOD-samples). $t$ authentication paths, for a Merkle tree of $|\\mathcal{L}|/k$ leaves, where each leaf is in $\\mathbb{F}^k$. Assuming that the digest size of the Merkle hash is $2\\lambda$ bits, and not accounting for path pruning (which in practice has a large impact), the argument size in bits is then: $$ (1 + t \\cdot \\log(|\\mathcal{L}|/k)) \\cdot 2\\lambda + (s + t \\cdot k) \\cdot \\log |\\mathbb{F}| \\enspace. $$\nVerifier time The verifier performs the following operations:\nDerives $\\alpha \\in \\mathbb{F}$ by FS. Derives $x_1, \\dots, x_s \\in \\mathbb{F}$ by FS. Derives $v_1, \\dots, v_t \\in \\mathcal{L}^k$ by FS. Queries $f$ at $t$ locations: Each query involves reading $k$ fields element and verify a Merkle authentication path of a Merkle tree with $|L|/k$ leaves. Derive the value of $f$ at those $t \\cdot k$ locations. In the first iteration, this requires no additional field operations. In latter rounds, the function $f$ is defined as $$ f(x) = \\mathsf{DegCorr}\\left(\\frac{g‚Äô(x) - \\mathsf{Ans}(x)}{V(x)}\\right) $$ where $g‚Äô$ is the oracle sent in the previous round, $\\mathsf{Ans}, V$ are polynomials of degree $\u003c t‚Äô + s‚Äô$ (where $t‚Äô, s‚Äô$ are the queries and OOD repetition of the last iterations). The degree correction is a (small) constant number of field operations. The two polynomials can be computed by interpolation (or with prover assistance, more on this soon‚Ñ¢Ô∏è) at the beginning of the iteration and so the cost is ammortised across each queries. Thus, each of these queries only requires evaluating these polynomials at a random point, which costs $O(t‚Äô + s‚Äô)$ fops. Once the value of $f$ is computed, the verifier computes the Fold which costs $O(k)$ fops (or $O(k \\cdot \\log k)$ fops if using an IFFT for this interpolation, the latter seems asymptotically worse but concretely more efficient in my experiments). So, in the first iteration the verifier cost is: $$ (1 + s + t) \\cdot \\mathsf{FS} + t \\cdot \\log(|L|/k) \\cdot \\mathsf{H} + O(t \\cdot k) \\cdot \\mathbb{F} \\enspace. $$ In the latter iterations instead it is $$ (1 + s + t) \\cdot \\mathsf{FS} + t \\cdot \\log(|L|/k) \\cdot \\mathsf{H} + O\\left(t \\cdot k \\cdot (t‚Äô + s‚Äô + 1) \\right) \\cdot \\mathbb{F} \\enspace. $$\nThere are additional tricks that can be done to further drive down the verifier costs. For example, instead of quotienting by $t + s$ points to define the next function to be tested, one can define $t$ functions, each of them consisting of quotients of $1 + s$ points, and test a (degree corrected) random linear combination of them.\nFor simplicity, I am using a single field here. In practice, you probably would want to have $\\mathbb{F} \\subseteq \\mathbb{H}$ where $\\mathbb{H}$ is the extension field you sample from. Since handling this is identical to FRI, I simply won‚Äôt.¬†‚Ü©Ô∏é\n","wordCount":"1303","inLanguage":"en","datePublished":"2024-02-21T00:00:00Z","dateModified":"2024-02-21T00:00:00Z","author":{"@type":"Person","name":"Giacomo Fenzi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/blurbs/stir-parameters/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>STIR: Setting Parameters</h1><div class=post-meta><span title='2024-02-21 00:00:00 +0000 UTC'>February 2024</span>&nbsp;&#183;&nbsp;Giacomo Fenzi&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2024/390 rel="noopener noreferrer" target=_blank>ePrint: 2024/390</a></div></header><div class=post-content><p>Our recent work, STIR ü•£ (See <a href=https://ia.cr/2024/390 target=_blank>2024/390</a>
and <a href=https://wizardofmenlo.github.io/papers/stir/>blog-post.</a>
) is an IOPP for RS codes with improved query complexity compared to the state-of-the art, FRI.
Compared to FRI, STIR has a few more parameters that one can tweak, which can have a rather large impact on prover time, verifier time and argument size. This short blurb details what these parameters are, and how they translate, concretely, in the resulting argument.
I won&rsquo;t be completely formal here, details worked out are in Subsection 5.3, Section 6 and Appendix C of the STIR paper.</p><h2 id=parameters>Parameters</h2><p>In this note, we focus on a single iteration of STIR.
We assume that the following parameters are given:</p><ul><li>A security parameter$\lambda \in \mathbb{N}$.</li><li>The Reed-Solomon code being tested, this includes:<ul><li>A field $\mathbb{F}$<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</li><li>A smooth evaluation domain $\mathcal{L} \subseteq \mathbb{F}$.</li><li>A degree bound $d \in \mathbb{N}$.</li><li>An initial rate $\rho := \frac{d}{|\mathcal{L}|}$.</li></ul></li></ul><p>We assume that the proximity bound to be tested from here on is $\delta := 1 - \rho$ (i.e. we are assuming the conjecture and ignoring $\eta$.)
If instead $\delta$ is in unique decoding range, the protocol can be made simpler by removing the OOD samples. We do not discuss this here.</p><p>A parametrization for a STIR iteration consists of the following:</p><ul><li>An evaluation domain $\mathcal{L}^\star \subseteq \mathbb{F}$.</li><li>A folding parameter $k$.</li><li>The number of OOD-samples $s$.</li><li>The number of queries $t$.</li><li>The PoW bits $\lambda_b$.</li></ul><p>We note that the parameters of each STIR iteration can be chosen independently.</p><h2 id=setting-parameters>Setting parameters</h2><p>This is not the place to precisely tell people how to set the parameters for soundness to hold, that&rsquo;s what the paper is for.
Here I just want to give some intuition on how one would go about doing this.
First, I suppose that you would pick evaluation domain $\mathcal{L}^\star$ and folding parameter $k$. Letting $c := \frac{|\mathcal{L}|}{|\mathcal{L}^\star|}$, note that the rate of the new code being tested is $\rho^\star := (c/k) \cdot \rho$. The key observation of STIR is that a lower rate makes testing easier, so the smaller the value $c/k$ is the fewer queries we require in latter iterations. In the paper, we set $c = 2$ to keep a linear proof length, but this is by no means necessary. You can even pick $c &lt; 1$.
The tradeoff in chosing $\mathcal{L}^\star$ is that:</p><ul><li>Large $\mathcal{L}^\star$ drives the rate down and thus the number of queries in the <em>next</em> iteration quicker.</li><li>However, the prover is then less efficient (as an FFT over $\mathcal{L}^\star$ must be performed).</li></ul><p>Regarding the folding parameter $k$:</p><ul><li>A larger folding parameter $k$ reduces <em>both</em> the degree of the polynomial quicker and decreases the rate of the next iteration, also driving down the number of queris.</li><li>On the other end, the verifier now needs to (at least) compute larger folds, each of which has cost at least linear in $k$, and also needs to read more field elements.</li></ul><p>Once those two parameters are set, the OOD-samples should be set so that they reach $\lambda$ bits of security. In general, for most sane configurations $s = 1$ or $s = 2$ should suffice.</p><p>Finally, $t$ and $\lambda_b$ should be set so that $(1 - \delta)^t &lt; 2^{\lambda - \lambda_b}$. Here there are also some tradeoffs:</p><ul><li>A larger value of $\lambda_b$ drives down verifier time and argument size, at the cost of increased prover time.</li><li>Further, larger $t$ not only increases the argument size but also the verifier running time, as it requires to compute more folds (and the virtual functions become more expensive to compute).</li></ul><h2 id=prover-time>Prover time</h2><p>Prover time in a STIR iteration is easy to estimate.
We assume that the prover has access to the message $\hat{f} \in \mathbb{F}[X]$ of degree $d$ for the codeword $f: \mathcal{L} \to \mathbb{F}$ being tested.
The STIR prover does the following:</p><ol><li>Derives $\alpha \in \mathbb{F}$ by FS.</li><li>Computes $\hat{g} := \mathsf{PolyFold}(\hat{f}, \alpha, k) \in \mathbb{F}<input checked disabled type=checkbox> $ of degree $d/k$.</li><li>Evaluates $\hat{g}$ on $\mathcal{L}^\star $ via a FFT to compute a vector of evaluations $g: \mathcal{L}^\star \to \mathbb{F}$.</li><li>Commits to $g$ using a Merkle tree.</li><li>Derives $x_1, \dots, x_s \in \mathbb{F}$ by FS.</li><li>Evaluates $g$ at $x_1, \dots, x_s$ using Horner&rsquo;s rule.</li><li>Derives $v_1, \dots, v_t \in \mathcal{L}^k$ by FS.</li><li>Computes a new function $\hat{f}^\star \in \mathbb{F}<input checked disabled type=checkbox> $ of degree $d/k$ by quotienting $\hat{g}$ at $s + t$ points, and degree correcting.</li></ol><p>All summed up, the prover does:</p><ol><li>Squeeze $1 + s + t$ elements out of the FS sponge.</li><li>Computes $2 \cdot |\mathcal{L}^\star|$ hashes for the Merkle commitment.</li><li>Computes an FFT of size $|\mathcal{L}^\star|$ for polynomial of size $d/k$, resulting in $O(|\mathcal{L}^\star| \cdot \log d/k)$ fops.</li><li>Does an additional $O(d)$ fops to compute the folds and $O(d/k)$ fops to compute the quotient and the degree correction.</li></ol><p>So the prover costs are:
$$
(1 + s + t) \cdot \mathsf{FS} + 2 \cdot |\mathcal{L}^\star| \cdot \mathsf{H} + \mathsf{FFT}(\mathcal{L}^\star , d/k) + O(d + d/k) \cdot \mathbb{F}
$$</p><h2 id=argument-size>Argument size</h2><p>Argument size is also easy to estimate, it consists of:</p><ol><li>A single Merkle root (for $g: \mathcal{L}^\star \to \mathbb{F}$).</li><li>$s$ elements of $\mathbb{F}$ (for OOD-samples).</li><li>$t$ authentication paths, for a Merkle tree of $|\mathcal{L}|/k$ leaves, where each leaf is in $\mathbb{F}^k$.</li></ol><p>Assuming that the digest size of the Merkle hash is $2\lambda$ bits, and not accounting for path pruning (which in practice has a large impact), the argument size in bits is then:
$$
(1 + t \cdot \log(|\mathcal{L}|/k)) \cdot 2\lambda + (s + t \cdot k) \cdot \log |\mathbb{F}| \enspace.
$$</p><h2 id=verifier-time>Verifier time</h2><p>The verifier performs the following operations:</p><ol><li>Derives $\alpha \in \mathbb{F}$ by FS.</li><li>Derives $x_1, \dots, x_s \in \mathbb{F}$ by FS.</li><li>Derives $v_1, \dots, v_t \in \mathcal{L}^k$ by FS.</li><li>Queries $f$ at $t$ locations:<ul><li>Each query involves reading $k$ fields element and verify a Merkle authentication path of a Merkle tree with $|L|/k$ leaves.</li><li>Derive the value of $f$ at those $t \cdot k$ locations.<ul><li>In the first iteration, this requires no additional field operations.</li><li>In latter rounds, the function $f$ is defined as
$$
f(x) = \mathsf{DegCorr}\left(\frac{g&rsquo;(x) - \mathsf{Ans}(x)}{V(x)}\right)
$$ where $g&rsquo;$ is the oracle sent in the previous round, $\mathsf{Ans}, V$ are polynomials of degree $&lt; t&rsquo; + s&rsquo;$ (where $t&rsquo;, s&rsquo;$ are the queries and OOD repetition of the last iterations).</li><li>The degree correction is a (small) constant number of field operations.</li><li>The two polynomials can be computed by interpolation (or with prover assistance, more on this soon‚Ñ¢Ô∏è) at the beginning of the iteration and so the cost is ammortised across each queries.</li><li>Thus, each of these queries only requires evaluating these polynomials at a random point, which costs $O(t&rsquo; + s&rsquo;)$ fops.</li></ul></li><li>Once the value of $f$ is computed, the verifier computes the Fold which costs $O(k)$ fops (or $O(k \cdot \log k)$ fops if using an IFFT for this interpolation, the latter seems asymptotically worse but concretely more efficient in my experiments).</li></ul></li></ol><p>So, in the first iteration the verifier cost is:
$$
(1 + s + t) \cdot \mathsf{FS} + t \cdot \log(|L|/k) \cdot \mathsf{H} + O(t \cdot k) \cdot \mathbb{F} \enspace.
$$
In the latter iterations instead it is
$$
(1 + s + t) \cdot \mathsf{FS} + t \cdot \log(|L|/k) \cdot \mathsf{H} + O\left(t \cdot k \cdot (t&rsquo; + s&rsquo; + 1) \right) \cdot \mathbb{F} \enspace.
$$</p><p>There are additional tricks that can be done to further drive down the verifier costs. For example, instead of quotienting by $t + s$ points to define the next function to be tested, one can define $t$ functions, each of them consisting of quotients of $1 + s$ points, and test a (degree corrected) random linear combination of them.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>For simplicity, I am using a single field here. In practice, you probably would want to have $\mathbb{F} \subseteq \mathbb{H}$ where $\mathbb{H}$ is the extension field you sample from. Since handling this is identical to FRI, I simply won&rsquo;t.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/hashes/>hashes</a></li><li><a href=https://wizardofmenlo.github.io/tags/concrete/>concrete</a></li><li><a href=https://wizardofmenlo.github.io/tags/theory/>theory</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>