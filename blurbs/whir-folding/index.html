<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Speeding up fold computation | Giacomo's Blog</title><meta name=keywords content="hashes,concrete"><meta name=description content="Computing folds is a large portion of the verifier work in schemes like FRI, STIR and WHIR. We describe an optimization to reduce this cost."><meta name=author content="Giacomo Fenzi"><link rel=canonical href=https://wizardofmenlo.github.io/blurbs/whir-folding/><link crossorigin=anonymous href=/assets/css/stylesheet.5c3d2aa85a103c2d32fb4f6cbe26e29098f291f6fedf6b1d5b502c91573ae1ce.css integrity="sha256-XD0qqFoQPC0y+09svibikJjykfb+32sdW1AskVc64c4=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Speeding up fold computation"><meta property="og:description" content="Computing folds is a large portion of the verifier work in schemes like FRI, STIR and WHIR. We describe an optimization to reduce this cost."><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/blurbs/whir-folding/"><meta property="article:section" content="blurbs"><meta property="article:published_time" content="2024-10-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Speeding up fold computation"><meta name=twitter:description content="Computing folds is a large portion of the verifier work in schemes like FRI, STIR and WHIR. We describe an optimization to reduce this cost."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blurbs","item":"https://wizardofmenlo.github.io/blurbs/"},{"@type":"ListItem","position":2,"name":"Speeding up fold computation","item":"https://wizardofmenlo.github.io/blurbs/whir-folding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Speeding up fold computation","name":"Speeding up fold computation","description":"Computing folds is a large portion of the verifier work in schemes like FRI, STIR and WHIR. We describe an optimization to reduce this cost.","keywords":["hashes","concrete"],"articleBody":"Our recent work, WHIR üå™Ô∏è (See 2024/1586 and blog-post. ) is an IOPP for constrained RS codes with exceptionally fast verification. In this blog we explain in detail one of the optimization that we used to achieve a faster verifier, with applications to schemes such as FRI and STIR as well. Verifier complexity usually consists of two components: (i) an algebraic component and; (ii) computing hashes. Reducing the second load (ii) usually involves reducing the IOPP query complexity, which is the main objective of STIR and WHIR. The technique we describe next aims to reduce the other component of verifier cost.\nFolding One of the main components of FRI, STIR, and WHIR is the folding operation. For $L \\subseteq \\mathbb{F}$1, define $L^{2^k} = \\{ z^{2^k} : z \\in L \\}$ and, for $z \\in L^{2^k}$, let $\\mathcal{B}_z = \\{y \\in L : y^{2^k} = z \\}$. We define $\\mathsf{Interpol}$ to be the function that interpolates a polynomial given a list of evaluations, i.e. $\\hat{p} := \\mathsf{Interpol}(\\{1, ‚Ä¶, n\\}, (y_1, \\dots, y_n))$ is the minimal univariate polynomial such that, for $i \\in [n]$, $\\hat{p}(i) = y_i$.\nGiven a function $f: L \\to \\mathbb{F}$, the $k$-wise folding of $f$ at $\\alpha \\in \\mathbb{F}$ is defined as the function $\\mathsf{Fold}(f, \\alpha): L^{2^k} \\to \\mathbb{F}$ that maps $$ z^{2^k} \\mapsto \\mathsf{Interpol}(\\mathcal{B}_z, f(\\mathcal{B}_z))(\\alpha) $$\nWe also define the $k$-multilinear folding to be the function $\\mathsf{Fold}^{(k)}(f, (\\alpha_1, \\dots, \\alpha_k)): L^{2^k} \\to \\mathbb{F}$ obtained by applying the $2$-wise folding $k$ times.\nTypically:\nFRI uses $1$-wise folding, possibly $k$-wise folding. STIR uses $k$-wise folding, with $k \u003e 1$. WHIR uses $k$-multilinear folding, with $k \u003e 1$. In each of these schemes, the prover will commit to a function $f: L \\to \\mathbb{F}$ by sending a function $\\tilde{f}: L^{2^k} \\to \\mathbb{F}^{2^k}$ such that $\\tilde{f}(z^{2^k}) = f(\\mathcal{B}_z)$. The verifier will sample (a single or many) challenges $\\alpha$, and the verifier will require to compute the folding with respect to $\\alpha$ at some randomly sampled element of $L^{2^k}$.\nOptimizing folding The verifier can use the definition of folding to evaluate it. Naively, this is a quadratic cost, but in fact since $\\mathcal{B}_z$ is a smooth coset of $L$, the verifier can use an FFT to evaluate it in time $O(k \\cdot 2^k)$. In fact, since the verifier needs only to evaluate the polynomial at a single point, this can in fact be done in linear time $O(2^k)$ via some version of barycentric evaluation for such subsets. (See E.2 in SNARKs for C for example). Concretely, this seems to require $2 \\cdot (2^k - 1)$ multiplications.\nWe suggest the following optimization. Instead of committing to $f: L \\to \\mathbb{F}$ as beforehand:\nIn the univariate folding case the prover will commit to a related function $\\tilde{f}: L^{2^k} \\to \\mathbb{F}^{\u003c2^k} $ where $\\tilde{g}(z^{2^k}) = \\mathsf{Interpol}(\\mathcal{B}_z, f(\\mathcal{B_z}))$. In the multilinear folding case the prover will commit to a related function $\\tilde{f}: L^{2^k} \\to \\mathbb{F}^{\u003c 2}[X_1, \\dots, X_k]$ where $\\tilde{g}(z^{2^k}) = \\mathsf{Interpol}(\\mathcal{B}_z, f(\\mathcal{B_z}))$ (interpreted as a $k$-variate multilinear polynomial). Now, when computing the fold, the verifier can simply read the corresponding polynomial and evaluate it at the point $\\alpha$, which takes exactly $2^k$ multiplications, roughly a 2x improvement. Soundness holds since the prover is sending the same exactly information (as the two representations can be recovered from one-another).\nExperimentally, this gives around a 20% saving in the WHIR verification.\nwhich here we assume to be have a smooth order and a cyclic subgroup of $\\mathbb{F}^*$ (or coset of one).¬†‚Ü©Ô∏é\n","wordCount":"573","inLanguage":"en","datePublished":"2024-10-03T00:00:00Z","dateModified":"2024-10-03T00:00:00Z","author":{"@type":"Person","name":"Giacomo Fenzi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/blurbs/whir-folding/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Speeding up fold computation</h1><div class=post-meta><span title='2024-10-03 00:00:00 +0000 UTC'>October 2024</span>&nbsp;&#183;&nbsp;Giacomo Fenzi&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2024/1586 rel="noopener noreferrer" target=_blank>ePrint: 2024/1586</a></div></header><div class=post-content><p>Our recent work, WHIR üå™Ô∏è (See <a href=https://ia.cr/2024/1586 target=_blank>2024/1586</a>
and <a href=https://wizardofmenlo.github.io/papers/whir/>blog-post.</a>
) is an IOPP for constrained RS codes with exceptionally fast verification.
In this blog we explain in detail one of the optimization that we used to achieve a faster verifier, with applications to schemes such as FRI and STIR as well.
Verifier complexity usually consists of two components: (i) an algebraic component and; (ii) computing hashes.
Reducing the second load (ii) usually involves reducing the IOPP query complexity, which is the main objective of STIR and WHIR.
The technique we describe next aims to reduce the other component of verifier cost.</p><h2 id=folding>Folding</h2><p>One of the main components of FRI, STIR, and WHIR is the <em>folding</em> operation.
For $L \subseteq \mathbb{F}$<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, define $L^{2^k} = \{ z^{2^k} : z \in L \}$ and, for $z \in L^{2^k}$, let $\mathcal{B}_z = \{y \in L : y^{2^k} = z \}$. We define $\mathsf{Interpol}$ to be the function that interpolates a polynomial given a list of evaluations, i.e. $\hat{p} := \mathsf{Interpol}(\{1, &mldr;, n\}, (y_1, \dots, y_n))$ is the minimal univariate polynomial such that, for $i \in [n]$, $\hat{p}(i) = y_i$.</p><p>Given a function $f: L \to \mathbb{F}$, the <em>$k$-wise folding</em> of $f$ at $\alpha \in \mathbb{F}$ is defined as the function $\mathsf{Fold}(f, \alpha): L^{2^k} \to \mathbb{F}$ that maps
$$ z^{2^k} \mapsto \mathsf{Interpol}(\mathcal{B}_z, f(\mathcal{B}_z))(\alpha) $$</p><p>We also define the <em>$k$-multilinear folding</em> to be the function $\mathsf{Fold}^{(k)}(f, (\alpha_1, \dots, \alpha_k)): L^{2^k} \to \mathbb{F}$ obtained by applying the $2$-wise folding $k$ times.</p><p>Typically:</p><ul><li>FRI uses $1$-wise folding, possibly $k$-wise folding.</li><li>STIR uses $k$-wise folding, with $k > 1$.</li><li>WHIR uses $k$-multilinear folding, with $k > 1$.</li></ul><p>In each of these schemes, the prover will commit to a function $f: L \to \mathbb{F}$ by sending a function $\tilde{f}: L^{2^k} \to \mathbb{F}^{2^k}$ such that $\tilde{f}(z^{2^k}) = f(\mathcal{B}_z)$. The verifier will sample (a single or many) challenges $\alpha$, and the verifier will require to compute the folding with respect to $\alpha$ at some randomly sampled element of $L^{2^k}$.</p><h2 id=optimizing-folding>Optimizing folding</h2><p>The verifier can use the definition of folding to evaluate it. Naively, this is a quadratic cost, but in fact since $\mathcal{B}_z$ is a smooth coset of $L$, the verifier can use an FFT to evaluate it in time $O(k \cdot 2^k)$. In fact, since the verifier needs only to evaluate the polynomial at a single point, this can in fact be done in linear time $O(2^k)$ via some version of barycentric evaluation for such subsets. (See E.2 in <a href=https://eprint.iacr.org/2013/507.pdf target=_blank>SNARKs for C</a>
for example). Concretely, this seems to require $2 \cdot (2^k - 1)$ multiplications.</p><p>We suggest the following optimization. Instead of committing to $f: L \to \mathbb{F}$ as beforehand:</p><ul><li>In the univariate folding case the prover will commit to a related function $\tilde{f}: L^{2^k} \to \mathbb{F}^{&lt;2^k}<input checked disabled type=checkbox> $ where $\tilde{g}(z^{2^k}) = \mathsf{Interpol}(\mathcal{B}_z, f(\mathcal{B_z}))$.</li><li>In the multilinear folding case the prover will commit to a related function $\tilde{f}: L^{2^k} \to \mathbb{F}^{&lt; 2}[X_1, \dots, X_k]$ where $\tilde{g}(z^{2^k}) = \mathsf{Interpol}(\mathcal{B}_z, f(\mathcal{B_z}))$ (interpreted as a $k$-variate multilinear polynomial).</li></ul><p>Now, when computing the fold, the verifier can simply read the corresponding polynomial and evaluate it at the point $\alpha$, which takes exactly $2^k$ multiplications, roughly a <strong>2x</strong> improvement.
Soundness holds since the prover is sending the same exactly information (as the two representations can be recovered from one-another).</p><p>Experimentally, this gives around a 20% saving in the WHIR verification.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>which here we assume to be have a smooth order and a cyclic subgroup of $\mathbb{F}^*$ (or coset of one).&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/hashes/>hashes</a></li><li><a href=https://wizardofmenlo.github.io/tags/concrete/>concrete</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>