<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>zkSNARKs in the ROM with Unconditional UC-Security | Giacomo's Blog</title><meta name=keywords content="concrete,theory"><meta name=description content="We show that commonly deployed zkSNARKs are UC-secure in the ROM, with no modifications needed."><meta name=author content="Alessandro Chiesa, Giacomo Fenzi"><link rel=canonical href=https://wizardofmenlo.github.io/papers/uc-snarks/><link crossorigin=anonymous href=/assets/css/stylesheet.5c3d2aa85a103c2d32fb4f6cbe26e29098f291f6fedf6b1d5b502c91573ae1ce.css integrity="sha256-XD0qqFoQPC0y+09svibikJjykfb+32sdW1AskVc64c4=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="zkSNARKs in the ROM with Unconditional UC-Security"><meta property="og:description" content="We show that commonly deployed zkSNARKs are UC-secure in the ROM, with no modifications needed."><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/papers/uc-snarks/"><meta property="article:section" content="papers"><meta property="article:published_time" content="2024-05-10T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="zkSNARKs in the ROM with Unconditional UC-Security"><meta name=twitter:description content="We show that commonly deployed zkSNARKs are UC-secure in the ROM, with no modifications needed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Papers","item":"https://wizardofmenlo.github.io/papers/"},{"@type":"ListItem","position":2,"name":"zkSNARKs in the ROM with Unconditional UC-Security","item":"https://wizardofmenlo.github.io/papers/uc-snarks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"zkSNARKs in the ROM with Unconditional UC-Security","name":"zkSNARKs in the ROM with Unconditional UC-Security","description":"We show that commonly deployed zkSNARKs are UC-secure in the ROM, with no modifications needed.","keywords":["concrete","theory"],"articleBody":"This blog-post is a short introduction to our new work: “zkSNARKs in the ROM with Unconditional UC-Security”. This is joint work with Alessandro Chiesa, and the full version is available on ePrint. The Universal Composability (UC) [Can01]1 framework is a “gold-standard” for security in cryptography. UC-secure protocols achieve strong security guarantees against powerful adaptive adversaries, and retain these guarantees when used as part of larger protocols. Zero knowledge succinct non-interactive arguments of knowledge are often used within larger protocols deployed in dynamic environments, and so UC-security is a highly desirable, if not necessary, goal.\nIn this work, we show that widely studied and deployed zkSNARKs in the ROM are UC-secure without modifications. Our main theorem states that:\nzkSNARKs constructed by instantiating the [BCS]2 construction with a suitable IOP are unconditionally UC-secure\nAbove, suitable IOPs are those that zero-knowledge and (state-restoration) knowledge sound, which are the same conditions required for the BCS construction to yield zero-knowledge and knowledge sound arguments in the ROM. So, achieving UC-secure zkSNARKs require no additional strengthening of the building blocks used to construct those zkSNARKs.\nUnconditional in our setting refers to the fact that our zkSNARKs are secure in the pure random oracle model, and the security is statistical and depends only on the number of queries the environment makes to the random oracle. Further, we also show that the zkSNARKs that we consider are UC-secure in the face of adaptive corruptions.\nFinally, all our results come with concrete security bounds, which inform how to set parameters in real systems.\nModelling We consider UC-security in the UC with global subroutines framework [BCHTZ20]3, and the global subroutine that we consider is that of the restricted observable programmable global random oracle model [CDGLN18]4. This GROM has an interface consisting of four methods: a query method, a programming method, a observe method and a is-programmed method. The query method models a standard random oracle query. The programming method allows every party in the security experiment to program the GROM, and this power is kept “in check” by the is-programmed method, which allows honest parties to detect whether a point was programmed or not. By this, the simulator is the only party that is allowed to program the GROM undetectably. Finally, the observe method allows gathering the queries made to the GROM by parties outside of the session. Roughly, in Micali and BCS, programming is required for zero-knowledge, while observability for knowledge soundness. Since in our setting we target unconditional UC-security, we slightly modify the UC-framework to account for environments that are computationally unbounded and whose only limits are in the number of time they can access “resources”. To do so, we introduce a mechanism of budgets. In our main experiment, the budgets will reflect GROM queries and programming queries and queries to the proving and verification interface.\nUC-friendly properties Our UC-security proof is modular. We show that any argument (in the ROM) that satisfies three strong security properties yields a UC-secure argument. The three properties we define are:\nUC-friendly completeness UC-friendly zero knowledge UC-friendly knowledge soundness We further show that these properties are in fact necessary for UC-security, giving us confidence that they really are the “right ones”.\nIn each setting we consider adversaries that have adaptive access to random, programming, prover and verifier oracles. Each property then reflects a corresponding property in the ROM that should be upheld in the face of this strong adversarial model.\nUC-friendly completeness states that such an adversary cannot cause the prover oracle to output proofs that are not subsequently accepted. Since the adversary has access to a programming oracle, perfect completeness of the underlying argument is in fact not sufficient, and we show a separation. We further puth forth a set of convenient properties that, together with perfect completeness, imply UC-friendly completeness. UC-friendly zero knowledge states that the adversary cannot distinguish between two security experiments, in the first of which the prover oracle returns honestly generated proofs and in the latter those proofs are in fact generated by a simulator (which has no access to the witness). Again, we show that adaptive zero knowledge in the ROM does not suffice for achieving this UC-friendly security notion. UC-friendly knowledge soundness states that an adversary cannot produce instance-proof pairs that validate successfully but from which an extractor is unable to extract a valid witness (for the corresponding instance). This is a strengthening of simulation extractability to our strong adversarial model. In fact, here we do not know of a separation, and we leave figuring out if one exists to future work. Micali and BCS security In light of the previous section, to show that the Micali and BCS construction are UC-secure showing that the satisfy these UC-friendly properties suffices. We focus on Micali for simplicity here, but the case for BCS is entirely analogous.\nUC-friendly completeness follows from perfect completeness of Micali and by showing that it satisfy two properties that we call monotone proofs and unpredictable queries. Roughly, since the prover queries will be unpredictable and the verifier only queries what the prover has previously queried, the adversary cannot use programming to influence verification. UC-friendly zero knowledge follows by a careful analysis of the Micali zero knowledge simulator (which requires zero knowledge of the underlying PCP) and by showing that Merkle trees satisfy a notion of UC-friendly hiding. UC-friendly knowledge soundness was harder to prove, but ultimately comes down to reducing to straightline state-restoration knowledge soundness of the underlying PCP (which is implied by knowledge soundness of the PCP) and an analysis of Merkle trees that show that they satisfy a notion of UC-friendly extraction suitable for this reduction. We note that, by restricting the adversarial capabilities, our work also shows a full end-to-end proof that Micali and BCS are perfectly complete, adaptive zero knowledge and (straightline) simulation knowledge sound.\nAdaptive corruptions Finally, we strengthen each of the properties to show that Micali and BCS in fact satisfy a stronger still notion of UC-security: they are secure in the face of adversaries that can adaptively corrupt parties in the security experiment and force them to reveal the randomness used thus far. This requires a strengthening of the underlying information theoretical building blocks, and we both show PCPs that satisfy this notion and by inspection conclude that common zero knowledge IOPs already satisfy this strengthening.\nCitation A. Chiesa, G. Fenzi. “zkSNARKs in the ROM with Unconditional UC-Security”. Cryptology ePrint Archive, Paper 2024/724. Available at: https://ia.cr/2024/724 .\n@misc{ChiesaFenzi24, author = {Alessandro Chiesa and Giacomo Fenzi}, title = {zkSNARKs in the ROM with Unconditional UC-Security}, howpublished = {Cryptology ePrint Archive, Paper 2024/724}, year = {2024}, note = {\\url{https://eprint.iacr.org/2024/724}}, url = {https://eprint.iacr.org/2024/724} } Related material [Can01] Ran Canetti. “Universally Composable Security: A New Paradigm for Cryptographic Protocols”. In: Proceedings of the 42nd Annual IEEE Symposium on Foundations of Computer Science. FOCS ’01. 2001, pp. 136–145. ↩︎\n[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: Proceed- ings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60. ↩︎\n[BCHTZ20] Christian Badertscher, Ran Canetti, Julia Hesse, Bjorn Tackmann, and Vassilis Zikas. “Universal Composition with Global Subroutines: Capturing Global Setup Within Plain UC”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC 20. 2020, pp. 1–30. ↩︎\n[CDGLN18] Jan Camenisch, Manu Drijvers, Tommaso Gagliardoni, Anja Lehmann, and Gregory Neven. “The Wonderful World of Global Random Oracles”. In: Proceedings of the 37th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’18. 2018, pp. 280–312. ↩︎\n","wordCount":"1240","inLanguage":"en","datePublished":"2024-05-10T00:00:00Z","dateModified":"2024-05-10T00:00:00Z","author":{"@type":"Person","name":"Alessandro Chiesa, Giacomo Fenzi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/papers/uc-snarks/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>zkSNARKs in the ROM with Unconditional UC-Security</h1><div class=post-meta><span title='2024-05-10 00:00:00 +0000 UTC'>May 2024</span>&nbsp;&#183;&nbsp;Alessandro Chiesa, Giacomo Fenzi&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2024/724 rel="noopener noreferrer" target=_blank>TCC 2024 - ePrint: 2024/724</a></div></header><div class=post-content><p>This blog-post is a short introduction to our new work: &ldquo;zkSNARKs in the ROM with Unconditional UC-Security&rdquo;. This is joint work with <a href=https://ic-people.epfl.ch/~achiesa/ target=_blank>Alessandro Chiesa,</a>
and the full version is <a href=https://eprint.iacr.org/2024/724 target=_blank>available on ePrint.</a></p><p>The Universal Composability (UC) [Can01]<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> framework is a &ldquo;gold-standard&rdquo; for security in cryptography.
UC-secure protocols achieve strong security guarantees against powerful adaptive adversaries, and retain these guarantees when used as part of larger protocols. Zero knowledge succinct non-interactive arguments of knowledge are often used within larger protocols deployed in dynamic environments, and so UC-security is a highly desirable, if not necessary, goal.</p><p>In this work, we show that widely studied and deployed zkSNARKs in the ROM are UC-secure without modifications. Our main theorem states that:</p><p><em>zkSNARKs constructed by instantiating the [BCS]<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> construction with a suitable IOP are unconditionally UC-secure</em></p><p>Above, suitable IOPs are those that zero-knowledge and (state-restoration) knowledge sound, which are the <strong>same conditions</strong> required for the BCS construction to yield zero-knowledge and knowledge sound arguments in the ROM. So, achieving UC-secure zkSNARKs require <strong>no</strong> additional strengthening of the building blocks used to construct those zkSNARKs.</p><p>Unconditional in our setting refers to the fact that our zkSNARKs are secure in the pure random oracle model, and the security is statistical and depends only on the number of queries the environment makes to the random oracle. Further, we also show that the zkSNARKs that we consider are UC-secure in the face of adaptive corruptions.</p><p>Finally, all our results come with <strong>concrete security bounds</strong>, which inform how to set parameters in real systems.</p><h2 id=modelling>Modelling</h2><p>We consider UC-security in the UC with global subroutines framework [BCHTZ20]<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, and the global subroutine that we consider is that of the restricted observable programmable global random oracle model [CDGLN18]<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. This GROM has an interface consisting of four methods: a query method, a programming method, a observe method and a is-programmed method. The query method models a standard random oracle query. The programming method allows <em>every party</em> in the security experiment to program the GROM, and this power is kept &ldquo;in check&rdquo; by the is-programmed method, which allows honest parties to detect whether a point was programmed or not. By this, the simulator is the only party that is allowed to program the GROM undetectably. Finally, the observe method allows gathering the queries made to the GROM by parties outside of the session. Roughly, in Micali and BCS, programming is required for zero-knowledge, while observability for knowledge soundness.
Since in our setting we target unconditional UC-security, we slightly modify the UC-framework to account for environments that are computationally unbounded and whose only limits are in the number of time they can access &ldquo;resources&rdquo;. To do so, we introduce a mechanism of <strong>budgets</strong>. In our main experiment, the budgets will reflect GROM queries and programming queries and queries to the proving and verification interface.</p><h2 id=uc-friendly-properties>UC-friendly properties</h2><p>Our UC-security proof is modular. We show that any argument (in the ROM) that satisfies three strong security properties yields a UC-secure argument.
The three properties we define are:</p><ol><li>UC-friendly completeness</li><li>UC-friendly zero knowledge</li><li>UC-friendly knowledge soundness</li></ol><p>We further show that these properties are in fact <em>necessary</em> for UC-security, giving us confidence that they really are the &ldquo;right ones&rdquo;.</p><p>In each setting we consider adversaries that have adaptive access to random, programming, prover and verifier oracles.
Each property then reflects a corresponding property in the ROM that should be upheld in the face of this strong adversarial model.</p><ol><li>UC-friendly completeness states that such an adversary cannot cause the prover oracle to output proofs that are not subsequently accepted. Since the adversary has access to a programming oracle, perfect completeness of the underlying argument is in fact not sufficient, and we show a separation. We further puth forth a set of convenient properties that, together with perfect completeness, imply UC-friendly completeness.</li><li>UC-friendly zero knowledge states that the adversary cannot distinguish between two security experiments, in the first of which the prover oracle returns honestly generated proofs and in the latter those proofs are in fact generated by a simulator (which has no access to the witness). Again, we show that adaptive zero knowledge in the ROM does not suffice for achieving this UC-friendly security notion.</li><li>UC-friendly knowledge soundness states that an adversary cannot produce instance-proof pairs that validate successfully but from which an extractor is unable to extract a valid witness (for the corresponding instance). This is a strengthening of simulation extractability to our strong adversarial model. In fact, here we do not know of a separation, and we leave figuring out if one exists to future work.</li></ol><h2 id=micali-and-bcs-security>Micali and BCS security</h2><p>In light of the previous section, to show that the Micali and BCS construction are UC-secure showing that the satisfy these UC-friendly properties suffices. We focus on Micali for simplicity here, but the case for BCS is entirely analogous.</p><ol><li>UC-friendly completeness follows from perfect completeness of Micali and by showing that it satisfy two properties that we call monotone proofs and unpredictable queries. Roughly, since the prover queries will be unpredictable and the verifier only queries what the prover has previously queried, the adversary cannot use programming to influence verification.</li><li>UC-friendly zero knowledge follows by a careful analysis of the Micali zero knowledge simulator (which requires zero knowledge of the underlying PCP) and by showing that Merkle trees satisfy a notion of UC-friendly hiding.</li><li>UC-friendly knowledge soundness was harder to prove, but ultimately comes down to reducing to straightline state-restoration knowledge soundness of the underlying PCP (which is implied by knowledge soundness of the PCP) and an analysis of Merkle trees that show that they satisfy a notion of UC-friendly extraction suitable for this reduction.</li></ol><p>We note that, by restricting the adversarial capabilities, our work also shows a full end-to-end proof that Micali and BCS are perfectly complete, adaptive zero knowledge and (straightline) simulation knowledge sound.</p><h2 id=adaptive-corruptions>Adaptive corruptions</h2><p>Finally, we strengthen each of the properties to show that Micali and BCS in fact satisfy a stronger still notion of UC-security: they are secure in the face of adversaries that can adaptively corrupt parties in the security experiment and force them to reveal the randomness used thus far. This requires a strengthening of the underlying information theoretical building blocks, and we both show PCPs that satisfy this notion and by inspection conclude that common zero knowledge IOPs already satisfy this strengthening.</p><hr><h5 id=citation>Citation</h5><p>A. Chiesa, G. Fenzi. &ldquo;<em>zkSNARKs in the ROM with Unconditional UC-Security</em>&rdquo;. Cryptology ePrint Archive, Paper 2024/724. Available at: <a href=https://ia.cr/2024/724 target=_blank>https://ia.cr/2024/724</a>
.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-BibTeX data-lang=BibTeX><span style=display:flex><span><span style=color:#0a0;text-decoration:underline>@misc</span>{ChiesaFenzi24,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>author</span>       = <span style=color:#a50>{Alessandro Chiesa and Giacomo Fenzi}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>title</span>        = <span style=color:#a50>{zkSNARKs in the ROM with Unconditional UC-Security}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>howpublished</span> = <span style=color:#a50>{Cryptology ePrint Archive, Paper 2024/724}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>year</span>         = <span style=color:#a50>{2024}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>note</span>         = <span style=color:#a50>{\url{https://eprint.iacr.org/2024/724}}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>url</span>          = <span style=color:#a50>{https://eprint.iacr.org/2024/724}</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h5 id=related-material>Related material</h5><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>[Can01] Ran Canetti. “Universally Composable Security: A New Paradigm for Cryptographic Protocols”. In: Proceedings of the 42nd Annual IEEE Symposium on Foundations of Computer Science. FOCS ’01. 2001, pp. 136–145.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: Proceed- ings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>[BCHTZ20] Christian Badertscher, Ran Canetti, Julia Hesse, Bjorn Tackmann, and Vassilis Zikas. “Universal Composition with Global Subroutines: Capturing Global Setup Within Plain UC”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC 20. 2020, pp. 1–30.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>[CDGLN18] Jan Camenisch, Manu Drijvers, Tommaso Gagliardoni, Anja Lehmann, and Gregory Neven. “The Wonderful World of Global Random Oracles”. In: Proceedings of the 37th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’18. 2018, pp. 280–312.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/concrete/>concrete</a></li><li><a href=https://wizardofmenlo.github.io/tags/theory/>theory</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>