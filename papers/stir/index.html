<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries | Giacomo's Blog</title><meta name=keywords content="hashes,concrete,theory"><meta name=description content="We present STIR (Shift To Improve Rate), a concretely efficient interactive oracle proof of proximity (IOPP) for Reed‚ÄìSolomon codes that achieves the best known query complexity of any concretely efficient IOPP for this problem."><meta name=author content="Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev"><link rel=canonical href=https://wizardofmenlo.github.io/papers/stir/><link crossorigin=anonymous href=/assets/css/stylesheet.5c3d2aa85a103c2d32fb4f6cbe26e29098f291f6fedf6b1d5b502c91573ae1ce.css integrity="sha256-XD0qqFoQPC0y+09svibikJjykfb+32sdW1AskVc64c4=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries"><meta property="og:description" content="We present STIR (Shift To Improve Rate), a concretely efficient interactive oracle proof of proximity (IOPP) for Reed‚ÄìSolomon codes that achieves the best known query complexity of any concretely efficient IOPP for this problem."><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/papers/stir/"><meta property="og:image" content="https://wizardofmenlo.github.io/stir_logo.jpg"><meta property="article:section" content="papers"><meta property="article:published_time" content="2024-02-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-21T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wizardofmenlo.github.io/stir_logo.jpg"><meta name=twitter:title content="STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries"><meta name=twitter:description content="We present STIR (Shift To Improve Rate), a concretely efficient interactive oracle proof of proximity (IOPP) for Reed‚ÄìSolomon codes that achieves the best known query complexity of any concretely efficient IOPP for this problem."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Papers","item":"https://wizardofmenlo.github.io/papers/"},{"@type":"ListItem","position":2,"name":"STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries","item":"https://wizardofmenlo.github.io/papers/stir/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries","name":"STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries","description":"We present STIR (Shift To Improve Rate), a concretely efficient interactive oracle proof of proximity (IOPP) for Reed‚ÄìSolomon codes that achieves the best known query complexity of any concretely efficient IOPP for this problem.","keywords":["hashes","concrete","theory"],"articleBody":"This blog-post is a short introduction to our new work: ‚ÄúSTIR: Reed-Solomon Proximity Testing with Fewer Queries‚Äù. This is joint work with Gal Arnon , Alessandro Chiesa , and Eylon Yogev , and the full version is available on ePrint . Code is also available at WizardOfMenlo/stir .\nDenote by $\\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]$ the Reed-Solomon (RS) code1 over the field $\\mathbb{F}$ of rate $\\rho = d/|\\mathcal{L}|$. Testing proximity to a RS code is the problem of, given oracle access to $f: \\mathcal{L} \\to \\mathbb{F}$, determining whether\n$f \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]$ i.e., $f$ is a RS codeword. $\\Delta(f, \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]) \u003e \\delta$ i.e., $f$ is $\\delta$-far (in terms of Hamming distance) from any RS codeword. In this work, we consider Interactive Oracle Proofs of Proximity (IOPP) for RS codes, i.e., interactive protocols between a prover and a verifier that aims to test proximity to a RS code in which the prover sends oracle messages.\nThe FRI protocol [BBHR18, BCIKS20]2 3 is one such IOPP, and underlies many SNARK-based real-world systems which offer state-of-the-art technology that protects billions of dollars‚Äô worth of transactions in blockchains.\nSTIR ü•£ We present STIR (Shift To Improve Rate), a concretely efficient IOPP for RS codes that achieves the best known query complexity of any concretely efficient IOPP for this problem.\nWhen compiled into an argument, STIR compares favourably to FRI in (i) argument size (ii) verifier time (iii) verifier hashes.\nTaking $d = 2^{24}$ and $\\rho = 1/2$ as an example:\nSTIR arguments‚Äô have size 160 KiB compared to FRI‚Äôs 306 KiB (1.8x better). STIR verifier‚Äôs perform 2600 hashes compared to FRI‚Äôs 5600 (2.13x better). STIR verifier‚Äôs runtime is 3.8ms compared to FRI‚Äôs 3.9ms (1.03x better). High-level overview The core intuition behind STIR is that decreasing rate makes proximity testing easier. Intuitively, the lower the rate the more redundant the code is, and thus the verifier can make use of more structure in its testing.\nFix $k$ a ‚Äúfolding parameter‚Äù, a proximity parameter $\\delta$, and a repetition parameter $t$.\nLet $\\mathcal{C} := \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]$ and $\\mathcal{C‚Äô} := \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}‚Äô, d/k]$ with $|\\mathcal{L}‚Äô| = |\\mathcal{L}|/2$ be two RS codes, and let $\\rho, \\rho‚Äô$ be their rates.\nA STIR iteration performs $t$ queries while fulfilling two roles:\nReduces testing proximity of $f$ to $\\mathcal{C}$ to testing proximity of a new (virtual) function $f‚Äô$ to $\\mathcal{C‚Äô}$. Amplifies distance. Roughly, if $f$ is $\\delta$-far from $\\mathcal{C}$, then $f‚Äô$ is $(1 - \\sqrt{\\rho‚Äô})$-far5 from $\\mathcal{C‚Äô}$ (except with probability roughly $(1 - \\delta)^t$, we dub this a ‚Äúbad event‚Äù). Testing proximity to $\\mathcal{C}‚Äô$ is now easier. First, the polynomial has had its degree reduced by a factor of $k$. Second, note that $\\rho‚Äô = (2/k) \\cdot \\rho$, so if $k \u003e 2$ then $\\rho‚Äô \u003c \\rho$, so the rate has improved.\nImagine now applying $M$ STIR iterations. Let $f_i, t_i$, $\\mathcal{L}_i$ be the functions tested, repetition parameters and domains at each round. Let also $\\rho_i := (2/k)^i \\cdot \\rho$ and $d_i = d/k^i$. At the end of those iterations, the (honest) prover will send a polynomial $\\hat{p}$ of degree $d_M$. The verifier then checks at $t_M$ points of $\\mathcal{L}_M$ that $f_M(x) = \\hat{p}(x)$.\nLet‚Äôs analyse soundness of this protocol. First, we bound the probability of a bad event happening at each iteration. At the first round, this probability is $(1 - \\delta)^{t_0}$. In later rounds, since the distance was amplified the probability is now: $$ (1 - (1 - \\sqrt{\\rho_i}))^{t_i} = \\rho_i^{t_i/2} $$ If none of these bad events happen, then the polynomial $\\hat{p}$ must be at distance $(1 - \\sqrt{\\rho_M})$ from $\\mathcal{C}_M$, and so the final check will detect this with probability at least $1 - \\rho_M^{t_M/2}$.\nThe overall soundness error of this protocol is then: $$ \\varepsilon \\leq (1 - \\delta)^{t_0} + \\sum_{i = 1}^M \\rho_i^{t_i/2}. $$\nAiming each term in the above sum to be $\\leq 2^{-\\lambda}$ so that $\\varepsilon \\leq (M+1) \\cdot 2^{-\\lambda}$, leads to setting $t_0 = \\frac{\\lambda}{- \\log (1 - \\delta)}$ and $t_i = \\frac{\\lambda}{- \\log \\sqrt{\\rho_i}}$.\nThe improved rate, translates in a decrease in the values of $t_i$ (apart from the first iteration). This is where STIR gains its efficiency.\nIn FRI, for example, the rate is unchanged between iterations, so each round (apart from the first) will query its corresponding oracle at least $\\frac{\\lambda}{- \\log \\sqrt{\\rho}}$ times. In fact, since FRI does correlated queries, the number of queries will be the same at each round as the first one, and at least $\\max \\left\\{\\frac{\\lambda}{-\\log (1 - \\delta)}, \\frac{\\lambda}{- \\log \\sqrt{\\rho}}\\right\\}$. Roughly then, the total number of queries of the FRI protocol is: $$ O\\left(\\lambda \\log d \\cdot \\max \\left\\{ \\frac{1}{-\\log (1-\\delta)}, \\frac{1}{-\\log \\sqrt{\\rho}} \\right\\}\\right) $$\nSTIR instead can perform only: $$ O\\left(\\frac{\\lambda}{-\\log (1 - \\delta)} + \\log d + \\lambda \\cdot \\log \\left(\\frac{\\log d}{-\\log \\sqrt{\\rho}}\\right)\\right) $$\nTechniques A STIR iteration roughly consists of the combination of two steps:\nFolding As in FRI, folding is the process of reducing the degree of a polynomial from $d$ to $d/k$ by decomposing it into $k$ polynomials of degree $d/k$ and taking a random combination of them. We rely mainly on two properties of folding:\nFolding preserves distance (except with probability at most $1 - \\mathrm{poly}(|\\mathcal{L}|)/\\mathbb{F}$, which, assuming a large field, is very small). Folding is local. Given oracle access to $f$, computing the value of the fold $f$ at a point in the folded domain is efficient (and involves querying $f$ at exactly $k$ locations). Quotienting The quotient of a function $f$ w.r.t to a function $p: S \\to \\mathbb{F}$ is the function of $X$ defined as: $$ \\frac{f(X) - \\hat{p}(X)}{\\prod_{a \\in S} (X - a)} $$ where $\\hat{p}$ is the polynomial interpolating $p$ over $S$. We rely on two properties of quotients:\nIf all low-degree polynomials close to $f$ disagree with $p$, then the quotient is far from the RS code. Quotienting is local. Given oracle access to $f$, computing the value of the quotient at a point is efficient (and involves querying $f$ at a single location). The STIR iteration We describe, at a high level, an iteration of STIR. Let $\\mathcal{L}^k = \\{ x^k : x \\in \\mathcal{L} \\}$.\nFolding-randomness: The verifier samples and sends $\\alpha \\gets \\mathbb{F}$. Fold: The prover sends $g$, the evaluation of the folding $\\hat{g}$ of $f$ around $\\alpha$ over $\\mathcal{L}‚Äô$. (Note, the folding would be a function $\\mathcal{L}^k \\to \\mathbb{F}$ where $|\\mathcal{L}^k| = |\\mathcal{L}|/k$, while here $\\mathcal{L‚Äô}$ is a domain of size $|\\mathcal{L}|/2$.) Out-of-domain sample: The verifier samples and sends $x \\gets \\mathbb{F}$. Out-of-domain reply: The prover sends $y = \\hat{g}(x)$. Shift-queries: The verifier samples $v_1, \\dots, v_t \\gets \\mathcal{L^k}$ and queries $f$ to compute the value of the folding of $f$ at these points (using the local mapping). Denote these values as $y_1, \\dots, y_t$. New-oracle: The verifier sets $p$ to be the function $p(x) = y$, $p(v_i) = y_i$. The new function $f‚Äô$ to be tested is then the quotient of $g$ w.r.t $p$. Roughly, the soundness analysis is the following:\nThe folding step preserves distance (except with small probability). The out-of-domain sample guarantees that there is at most one codeword $u$ within $1 - \\sqrt{\\rho‚Äô}$ distance of $g$ which has $\\hat{u}(x) = y$ (except with small probability). Now, if there is no such codeword, then $f$ will be $1 - \\sqrt{\\rho‚Äô}$ far from the RS code, since it is a quotient and $p(x) = y$. If instead such a codeword exists, by the first point $\\hat{u}$ can agree with the fold on at most a $1 - \\delta$ fraction of the domain (since the fold preserves distance). If any of the sampled points $v_i$ are in the disagreement portion, then again the quotient will be $1 - \\sqrt{\\rho‚Äô}$ far from the RS code. Thus this happens unless with probability $(1 - \\delta)^t$.\nBenchmarks We implemented STIR and FRI in Rust and compared their performance. Our code can be found at WizardOfMenlo/stir . Below, we present the results of our benchmarks when $\\rho = 1/2$\nComparison of FRI and STIR. FRI is red, STIR is blue. STIR obtains better argument size and verifier hash complexity than FRI for all tested parameters. The overall verifier runtime is also faster then FRI, especially for large degrees. Taking $d = 2^{24}$ and $\\rho = 1/2$ as an example:\nSTIR arguments‚Äô have size 160 KiB compared to FRI‚Äôs 306 KiB (1.8x better). STIR verifier‚Äôs perform 2600 hashes compared to FRI‚Äôs 5600 (2.13x better). STIR verifier‚Äôs runtime is 3.8ms compared to FRI‚Äôs 3.9ms (1.03x better). For a more detailed comparison, see Section 6 of the paper.\nPractical considerations We consider the prover costs of STIR. In practice, FRI is run in a heavily batched context i.e., instead of testing proximity of a single polynomial to a RS code, a random linear combination of a list of polynomials $f_1, \\dots, f_\\ell$ is tested. The dominating prover cost is then that of committing to the polynomials, which involves performing $\\ell$ FFTs to compute the evaluations of the $f_i$s over $\\mathcal{L}$ and then committing to said evaluation. This cost is shared by both FRI and STIR, and, especially in this batch setting, comes to dominate. The rest of the proximity test, which is where STIR is slower than FRI, is independent of the number of polynomials committed. So, changing from FRI to STIR should have an almost negligible effect on prover runtime.\nFurther, STIR‚Äôs improvement in query complexity enable new parameter tradeoffs in which one can achieve better prover time, argument sizes and verifier hash complexity than FRI. For example, [ethSTARK]6 uses FRI with $d = 2^{22}$ and $\\rho = 1/4$. In our experiments, FRI‚Äôs prover runs in 11s, yields arguments of size 154 KiB which can be verified by performing $\\approx 2800$ hashes. Instead, running STIR with $d = 2^{22}$ and $\\rho = 1/2$ yields a prover which runs in 10s, has arguments of size 143 KiB and a verifier which performs $\\approx 2200$ hashes. More generally, in the batched setting, we expect the dominating costs of both FRI and STIR to be proportional to $\\ell \\cdot d/\\rho$. If the improvements in argument size/verifier hash allow to set a larger rate (say by a factor of 2), the dominating cost of the STIR prover would as well decrease by that factor.\nCitation G. Arnon, A. Chiesa, G. Fenzi, E. Yogev. ‚ÄúSTIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries‚Äù. Cryptology ePrint Archive, Paper 2024/390. Available at: https://ia.cr/2024/390 .\n@misc{ArnonCFY, author = {Gal Arnon and Alessandro Chiesa and Giacomo Fenzi and Eylon Yogev}, title = {STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries}, howpublished = {Cryptology ePrint Archive, Paper 2024/390}, year = {2024}, note = {\\url{https://eprint.iacr.org/2024/390}}, url = {https://eprint.iacr.org/2024/390} } Related material Formally $\\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d] = \\{ \\hat{p}|_\\mathcal{L} : \\hat{p} \\in \\mathbb{F}^{\u003c d}[X] \\}$ where $\\hat{p}|_\\mathcal{L}: \\mathcal{L} \\to \\mathbb{F}$ is the restriction of $\\hat{p}$ to $\\mathcal{L}$.¬†‚Ü©Ô∏é\n[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. ‚ÄúFast Reed‚ÄìSolomon Interactive Oracle Proofs of Proximity‚Äù. In: Proceedings of the 45th International Colloquium on Automata, Languages and Programming. ICALP ‚Äô18. 2018,¬†‚Ü©Ô∏é\n[BCIKS20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. ‚ÄúProximity Gaps for Reed‚ÄìSolomon Codes‚Äù. In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science. FOCS ‚Äô20. 2020.¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é\n[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. ‚ÄúDEEP-FRI: Sampling Outside the Box Improves Soundness‚Äù. In: Proceedings of the 11th Innovations in Theoretical Computer Science Conference. ITCS ‚Äô20.¬†‚Ü©Ô∏é\nHere and throughout, distances of the form $1 - \\sqrt{\\rho}$ can be improved to $1 - \\rho$ by assuming a conjecture on the list-decoding of RS codes proposed in [BCIKS20,BGKS20] 34.¬†‚Ü©Ô∏é\n[ethSTARK] StarkWare. ethSTARK Documentation. Cryptology ePrint Archive, Paper 2021/582. https://eprint.iacr.org/2021/582 . 2021.¬†‚Ü©Ô∏é\n","wordCount":"1930","inLanguage":"en","image":"https://wizardofmenlo.github.io/stir_logo.jpg","datePublished":"2024-02-21T00:00:00Z","dateModified":"2024-02-21T00:00:00Z","author":{"@type":"Person","name":"Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/papers/stir/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries</h1><div class=post-meta><span title='2024-02-21 00:00:00 +0000 UTC'>February 2024</span>&nbsp;&#183;&nbsp;Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2024/390 rel="noopener noreferrer" target=_blank>ePrint: 2024/390</a></div></header><div class=post-content><p>This blog-post is a short introduction to our new work: &ldquo;STIR: Reed-Solomon Proximity Testing with Fewer Queries&rdquo;. This is joint work with <a href=https://galarnon42.github.io/ target=_blank>Gal Arnon</a>
, <a href=https://ic-people.epfl.ch/~achiesa/ target=_blank>Alessandro Chiesa</a>
, and <a href=https://www.eylonyogev.com/about target=_blank>Eylon Yogev</a>
, and the full version is <a href=https://eprint.iacr.org/2024/390 target=_blank>available on ePrint</a>
. Code is also available at <a href=https://github.com/WizardOfMenlo/stir target=_blank>WizardOfMenlo/stir</a>
.</p><p>Denote by $\mathsf{RS}[\mathbb{F}, \mathcal{L}, d]$ the Reed-Solomon (RS) code<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> over the field $\mathbb{F}$ of rate $\rho = d/|\mathcal{L}|$.
Testing proximity to a RS code is the problem of, given oracle access to $f: \mathcal{L} \to \mathbb{F}$, determining whether</p><ul><li>$f \in \mathsf{RS}[\mathbb{F}, \mathcal{L}, d]$ i.e., $f$ is a RS codeword.</li><li>$\Delta(f, \mathsf{RS}[\mathbb{F}, \mathcal{L}, d]) > \delta$ i.e., $f$ is $\delta$-far (in terms of Hamming distance) from any RS codeword.</li></ul><p>In this work, we consider Interactive Oracle Proofs of Proximity (IOPP) for RS codes, i.e., interactive protocols between a prover and a verifier that aims to test proximity to a RS code in which the prover sends oracle messages.</p><p>The FRI protocol [BBHR18, BCIKS20]<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> is one such IOPP, and underlies many SNARK-based real-world systems which offer state-of-the-art technology that protects billions of dollars&rsquo; worth of transactions in blockchains.</p><h1 id=stir->STIR ü•£</h1><p>We present STIR (Shift To Improve Rate), a concretely efficient IOPP for RS codes that achieves the best known query complexity of any concretely efficient IOPP for this problem.</p><p>When compiled into an argument, STIR compares favourably to FRI in (i) argument size (ii) verifier time (iii) verifier hashes.</p><p>Taking $d = 2^{24}$ and $\rho = 1/2$ as an example:</p><ul><li>STIR arguments&rsquo; have size 160 KiB compared to FRI&rsquo;s 306 KiB (<strong>1.8x better</strong>).</li><li>STIR verifier&rsquo;s perform 2600 hashes compared to FRI&rsquo;s 5600 (<strong>2.13x better</strong>).</li><li>STIR verifier&rsquo;s runtime is 3.8ms compared to FRI&rsquo;s 3.9ms (<strong>1.03x better</strong>).</li></ul><hr><h2 id=high-level-overview>High-level overview</h2><p>The core intuition behind STIR is that decreasing rate makes proximity testing easier. Intuitively, the lower the rate the more redundant the code is, and thus the verifier can make use of more structure in its testing.</p><p>Fix $k$ a &ldquo;folding parameter&rdquo;, a proximity parameter $\delta$, and a repetition parameter $t$.</p><p>Let $\mathcal{C} := \mathsf{RS}[\mathbb{F}, \mathcal{L}, d]$ and $\mathcal{C&rsquo;} := \mathsf{RS}[\mathbb{F}, \mathcal{L}&rsquo;, d/k]$ with $|\mathcal{L}&rsquo;| = |\mathcal{L}|/2$ be two RS codes, and let $\rho, \rho&rsquo;$ be their rates.</p><p>A STIR iteration performs $t$ queries while fulfilling two roles:</p><ol><li>Reduces testing proximity of $f$ to $\mathcal{C}$ to testing proximity of a new (virtual) function $f&rsquo;$ to $\mathcal{C&rsquo;}$.</li><li>Amplifies distance. Roughly, if $f$ is $\delta$-far from $\mathcal{C}$, then $f&rsquo;$ is $(1 - \sqrt{\rho&rsquo;})$-far<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> from $\mathcal{C&rsquo;}$ (except with probability roughly $(1 - \delta)^t$, we dub this a &ldquo;bad event&rdquo;).</li></ol><p>Testing proximity to $\mathcal{C}&rsquo;$ is now easier. First, the polynomial has had its degree reduced by a factor of $k$. Second, note that $\rho&rsquo; = (2/k) \cdot \rho$, so if $k > 2$ then $\rho&rsquo; &lt; \rho$, so the rate has improved.</p><p>Imagine now applying $M$ STIR iterations. Let $f_i, t_i$, $\mathcal{L}_i$ be the functions tested, repetition parameters and domains at each round. Let also $\rho_i := (2/k)^i \cdot \rho$ and $d_i = d/k^i$. At the end of those iterations, the (honest) prover will send a polynomial $\hat{p}$ of degree $d_M$. The verifier then checks at $t_M$ points of $\mathcal{L}_M$ that $f_M(x) = \hat{p}(x)$.</p><p>Let&rsquo;s analyse soundness of this protocol. First, we bound the probability of a bad event happening at each iteration. At the first round, this probability is $(1 - \delta)^{t_0}$. In later rounds, since the distance was amplified the probability is now:
$$
(1 - (1 - \sqrt{\rho_i}))^{t_i} = \rho_i^{t_i/2}
$$
If none of these bad events happen, then the polynomial $\hat{p}$ must be at distance $(1 - \sqrt{\rho_M})$ from $\mathcal{C}_M$, and so the final check will detect this with probability at least $1 - \rho_M^{t_M/2}$.</p><p>The overall soundness error of this protocol is then:
$$
\varepsilon \leq (1 - \delta)^{t_0} + \sum_{i = 1}^M \rho_i^{t_i/2}.
$$</p><p>Aiming each term in the above sum to be $\leq 2^{-\lambda}$ so that $\varepsilon \leq (M+1) \cdot 2^{-\lambda}$, leads to setting $t_0 = \frac{\lambda}{- \log (1 - \delta)}$ and $t_i = \frac{\lambda}{- \log \sqrt{\rho_i}}$.</p><p>The improved rate, translates in a decrease in the values of $t_i$ (apart from the first iteration).
This is where STIR gains its efficiency.</p><p>In FRI, for example, the rate is <em>unchanged</em> between iterations, so each round (apart from the first) will query its corresponding oracle at least $\frac{\lambda}{- \log \sqrt{\rho}}$ times.
In fact, since FRI does <em>correlated</em> queries, the number of queries will be the same at each round as the first one, and at least $\max \left\{\frac{\lambda}{-\log (1 - \delta)}, \frac{\lambda}{- \log \sqrt{\rho}}\right\}$.
Roughly then, the total number of queries of the FRI protocol is:
$$
O\left(\lambda \log d \cdot \max \left\{ \frac{1}{-\log (1-\delta)}, \frac{1}{-\log \sqrt{\rho}} \right\}\right)
$$</p><p>STIR instead can perform only:
$$
O\left(\frac{\lambda}{-\log (1 - \delta)} + \log d + \lambda \cdot \log \left(\frac{\log d}{-\log \sqrt{\rho}}\right)\right)
$$</p><hr><h2 id=techniques>Techniques</h2><p>A STIR iteration roughly consists of the combination of two steps:</p><h4 id=folding>Folding</h4><p>As in FRI, folding is the process of reducing the degree of a polynomial from $d$ to $d/k$ by decomposing it into $k$ polynomials of degree $d/k$ and taking a random combination of them.
We rely mainly on two properties of folding:</p><ol><li>Folding preserves distance (except with probability at most $1 - \mathrm{poly}(|\mathcal{L}|)/\mathbb{F}$, which, assuming a large field, is very small).</li><li>Folding is local. Given oracle access to $f$, computing the value of the fold $f$ at a point in the folded domain is efficient (and involves querying $f$ at exactly $k$ locations).</li></ol><h4 id=quotienting>Quotienting</h4><p>The quotient of a function $f$ w.r.t to a function $p: S \to \mathbb{F}$ is the function of $X$ defined as:
$$
\frac{f(X) - \hat{p}(X)}{\prod_{a \in S} (X - a)}
$$
where $\hat{p}$ is the polynomial interpolating $p$ over $S$.
We rely on two properties of quotients:</p><ol><li>If all low-degree polynomials close to $f$ disagree with $p$, then the quotient is far from the RS code.</li><li>Quotienting is local. Given oracle access to $f$, computing the value of the quotient at a point is efficient (and involves querying $f$ at a single location).</li></ol><h3 id=the-stir-iteration>The STIR iteration</h3><p>We describe, at a high level, an iteration of STIR. Let $\mathcal{L}^k = \{ x^k : x \in \mathcal{L} \}$.</p><ol><li><strong>Folding-randomness</strong>: The verifier samples and sends $\alpha \gets \mathbb{F}$.</li><li><strong>Fold</strong>: The prover sends $g$, the evaluation of the folding $\hat{g}$ of $f$ around $\alpha$ over $\mathcal{L}&rsquo;$. (Note, the folding would be a function $\mathcal{L}^k \to \mathbb{F}$ where $|\mathcal{L}^k| = |\mathcal{L}|/k$, while here $\mathcal{L&rsquo;}$ is a domain of size $|\mathcal{L}|/2$.)</li><li><strong>Out-of-domain sample</strong>: The verifier samples and sends $x \gets \mathbb{F}$.</li><li><strong>Out-of-domain reply</strong>: The prover sends $y = \hat{g}(x)$.</li><li><strong>Shift-queries</strong>: The verifier samples $v_1, \dots, v_t \gets \mathcal{L^k}$ and queries $f$ to compute the value of the folding of $f$ at these points (using the local mapping). Denote these values as $y_1, \dots, y_t$.</li><li><strong>New-oracle</strong>: The verifier sets $p$ to be the function $p(x) = y$, $p(v_i) = y_i$. The new function $f&rsquo;$ to be tested is then the quotient of $g$ w.r.t $p$.</li></ol><p>Roughly, the soundness analysis is the following:</p><ol><li>The folding step preserves distance (except with small probability).</li><li>The out-of-domain sample guarantees that there is at most one codeword $u$ within $1 - \sqrt{\rho&rsquo;}$ distance of $g$ which has $\hat{u}(x) = y$ (except with small probability).</li></ol><p>Now, if there is no such codeword, then $f$ will be $1 - \sqrt{\rho&rsquo;}$ far from the RS code, since it is a quotient and $p(x) = y$.
If instead such a codeword exists, by the first point $\hat{u}$ can agree with the fold on at most a $1 - \delta$ fraction of the domain (since the fold preserves distance). If any of the sampled points $v_i$ are in the disagreement portion, then again the quotient will be $1 - \sqrt{\rho&rsquo;}$ far from the RS code. Thus this happens unless with probability $(1 - \delta)^t$.</p><hr><h1 id=benchmarks>Benchmarks</h1><p>We implemented STIR and FRI in Rust and compared their performance. Our code can be found at <a href=https://github.com/WizardOfMenlo/stir target=_blank>WizardOfMenlo/stir</a>
.
Below, we present the results of our benchmarks when $\rho = 1/2$</p><h5 id=comparison-of-fri-and-stir-fri-is-red-stir-is-blue>Comparison of FRI and STIR. FRI is red, STIR is blue.</h5><p><img loading=lazy src=1_graph.jpg alt></p><p>STIR obtains better argument size and verifier hash complexity than FRI for all tested parameters. The overall verifier runtime is also faster then FRI, especially for large degrees.
Taking $d = 2^{24}$ and $\rho = 1/2$ as an example:</p><ul><li>STIR arguments&rsquo; have size 160 KiB compared to FRI&rsquo;s 306 KiB (<strong>1.8x better</strong>).</li><li>STIR verifier&rsquo;s perform 2600 hashes compared to FRI&rsquo;s 5600 (<strong>2.13x better</strong>).</li><li>STIR verifier&rsquo;s runtime is 3.8ms compared to FRI&rsquo;s 3.9ms (<strong>1.03x better</strong>).</li></ul><p>For a more detailed comparison, see Section 6 of the paper.</p><hr><h3 id=practical-considerations>Practical considerations</h3><p>We consider the prover costs of STIR. In practice, FRI is run in a heavily batched context i.e., instead of testing proximity of a single polynomial to a RS code, a random linear combination of a list of polynomials $f_1, \dots, f_\ell$ is tested. The dominating prover cost is then that of committing to the polynomials, which involves performing $\ell$ FFTs to compute the evaluations of the $f_i$s over $\mathcal{L}$ and then committing to said evaluation. This cost is shared by both FRI and STIR, and, especially in this batch setting, comes to dominate. The rest of the proximity test, which is where STIR is slower than FRI, is independent of the number of polynomials committed. So, changing from FRI to STIR should have an almost negligible effect on prover runtime.</p><p>Further, STIR&rsquo;s improvement in query complexity enable new parameter tradeoffs in which one can achieve better prover time, argument sizes and verifier hash complexity than FRI. For example, [ethSTARK]<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> uses FRI with $d = 2^{22}$ and $\rho = 1/4$. In our experiments, FRI&rsquo;s prover runs in 11s, yields arguments of size 154 KiB which can be verified by performing $\approx 2800$ hashes. Instead, running STIR with $d = 2^{22}$ and $\rho = 1/2$ yields a prover which runs in 10s, has arguments of size 143 KiB and a verifier which performs $\approx 2200$ hashes. More generally, in the batched setting, we expect the dominating costs of both FRI and STIR to be proportional to $\ell \cdot d/\rho$. If the improvements in argument size/verifier hash allow to set a larger rate (say by a factor of 2), the dominating cost of the STIR prover would as well decrease by that factor.</p><hr><h5 id=citation>Citation</h5><p>G. Arnon, A. Chiesa, G. Fenzi, E. Yogev. &ldquo;<em>STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries</em>&rdquo;. Cryptology ePrint Archive, Paper 2024/390. Available at: <a href=https://ia.cr/2024/390 target=_blank>https://ia.cr/2024/390</a>
.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-BibTeX data-lang=BibTeX><span style=display:flex><span><span style=color:#0a0;text-decoration:underline>@misc</span>{ArnonCFY,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>author</span>       = <span style=color:#a50>{Gal Arnon and Alessandro Chiesa and Giacomo Fenzi and Eylon Yogev}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>title</span>        = <span style=color:#a50>{STIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>howpublished</span> = <span style=color:#a50>{Cryptology ePrint Archive, Paper 2024/390}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>year</span>         = <span style=color:#a50>{2024}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>note</span>         = <span style=color:#a50>{\url{https://eprint.iacr.org/2024/390}}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>url</span>          = <span style=color:#a50>{https://eprint.iacr.org/2024/390}</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h5 id=related-material>Related material</h5><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Formally $\mathsf{RS}[\mathbb{F}, \mathcal{L}, d] = \{ \hat{p}|_\mathcal{L} : \hat{p} \in \mathbb{F}^{&lt; d}[X] \}$ where $\hat{p}|_\mathcal{L}: \mathcal{L} \to \mathbb{F}$ is the restriction of $\hat{p}$ to $\mathcal{L}$.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. ‚ÄúFast Reed‚ÄìSolomon Interactive Oracle Proofs of Proximity‚Äù. In: Proceedings of the 45th International Colloquium on Automata, Languages and Programming. ICALP ‚Äô18. 2018,&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>[BCIKS20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. ‚ÄúProximity Gaps for Reed‚ÄìSolomon Codes‚Äù. In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science. FOCS ‚Äô20. 2020.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. ‚ÄúDEEP-FRI: Sampling Outside the Box Improves Soundness‚Äù. In: Proceedings of the 11th Innovations in Theoretical Computer Science Conference. ITCS ‚Äô20.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Here and throughout, distances of the form $1 - \sqrt{\rho}$ can be improved to $1 - \rho$ by assuming a conjecture on the list-decoding of RS codes proposed in [BCIKS20,BGKS20] <sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>[ethSTARK] StarkWare. ethSTARK Documentation. Cryptology ePrint Archive, Paper 2021/582. <a href=https://eprint.iacr.org/2021/582 target=_blank>https://eprint.iacr.org/2021/582</a>
. 2021.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/hashes/>hashes</a></li><li><a href=https://wizardofmenlo.github.io/tags/concrete/>concrete</a></li><li><a href=https://wizardofmenlo.github.io/tags/theory/>theory</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>