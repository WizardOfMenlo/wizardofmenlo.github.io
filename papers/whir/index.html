<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification | Giacomo's Blog</title><meta name=keywords content="hashes,concrete,theory"><meta name=description content="We present WHIR (Weights Help Improving Rate), an interactive oracle proof of proximity (IOPP) for constrained Reed‚ÄìSolomon codes. WHIR doubles as a multilinear polynomial commitment scheme, achieving the fastest verification speed of any such scheme while mantaining state-of-the-art argument size, verifier hash complexity and prover times."><meta name=author content="Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev"><link rel=canonical href=https://wizardofmenlo.github.io/papers/whir/><link crossorigin=anonymous href=/assets/css/stylesheet.5c3d2aa85a103c2d32fb4f6cbe26e29098f291f6fedf6b1d5b502c91573ae1ce.css integrity="sha256-XD0qqFoQPC0y+09svibikJjykfb+32sdW1AskVc64c4=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification"><meta property="og:description" content="We present WHIR (Weights Help Improving Rate), an interactive oracle proof of proximity (IOPP) for constrained Reed‚ÄìSolomon codes. WHIR doubles as a multilinear polynomial commitment scheme, achieving the fastest verification speed of any such scheme while mantaining state-of-the-art argument size, verifier hash complexity and prover times."><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/papers/whir/"><meta property="article:section" content="papers"><meta property="article:published_time" content="2024-09-27T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification"><meta name=twitter:description content="We present WHIR (Weights Help Improving Rate), an interactive oracle proof of proximity (IOPP) for constrained Reed‚ÄìSolomon codes. WHIR doubles as a multilinear polynomial commitment scheme, achieving the fastest verification speed of any such scheme while mantaining state-of-the-art argument size, verifier hash complexity and prover times."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Papers","item":"https://wizardofmenlo.github.io/papers/"},{"@type":"ListItem","position":2,"name":"WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification","item":"https://wizardofmenlo.github.io/papers/whir/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification","name":"WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification","description":"We present WHIR (Weights Help Improving Rate), an interactive oracle proof of proximity (IOPP) for constrained Reed‚ÄìSolomon codes. WHIR doubles as a multilinear polynomial commitment scheme, achieving the fastest verification speed of any such scheme while mantaining state-of-the-art argument size, verifier hash complexity and prover times.","keywords":["hashes","concrete","theory"],"articleBody":"This blog-post is a short introduction to our new work: ‚ÄúWHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification‚Äù. This is joint work with Gal Arnon, Alessandro Chiesa, and Eylon Yogev, and the full version is available on ePrint . Code is also available at WizardOfMenlo/whir. WHIR üå™Ô∏è We present WHIR (Weights Help Improving Rate), a concretely efficient IOPP for constrained Reed‚ÄìSolomon codes1.\nWHIR is both an IOPP for Reed‚ÄìSolomon codes and a multilinear polynomial commitment scheme (PCS), and achieves the fastest verification speed of any such scheme, even including univariate PCS with trusted setup. It does so while mantaining state-of-the-art argument size and verifier hash complexity for hash-based schemes, requiring only transparent setup and guaranteeing post-quantum security.\nAs a multilinear and univariate PCS, WHIR achieve by far the smallest verification time across all scheme that we tested. Taking $d = 2^{24}$ as an example:\nAt the 100-bit security level, a WHIR proof verification takes between 610Œºs (with $\\rho = 1/2$) to 290Œºs (with $\\rho = 1/16$). This is a speedup of between 5700√ó-12000√ó against Brakedown, 1200√ó- 2500√ó against Ligero, 164√ó-345√ó against Hyrax, 13√ó-27√ó against PST and 4.0√ó-8.3√ó against KZG. At the 128-bit security level, a WHIR proof verification takes between 1.4ms to 700Œºs achieving a speedup of between 2600√ó-5300√ó against Brakedown, 535√ó-1100√ó against Ligero, 93√ó-186√ó against Greyhound, 108√ó-216√ó against Hyrax, 7√ó-14√ó against PST and 2.6√ó-5.2√ó against KZG. As a hash-based multilinear PCS, WHIR compares favourably to BaseFold in (i) argument size (ii) verifier time (iii) verifier hashes.\nTaking $d = 2^{24}$ and $\\rho = 1/2$ as an example, at the 100-bit security level:\nWHIR‚Äôs arguments are 101 KiB vs BaseFold‚Äôs 7.95 MiB (74√ó better). WHIR‚Äôs verifier runs in 610Œºs vs BaseFold‚Äôs 24ms (39√ó better). As a low-degree test, WHIR achieves best-in-class verifier time, while mantaining state-of-the-art argument size and verifier hash complexity. Taking $d = 2^{24}$ and $\\rho = 1/2$ as an example, at the 128-bit security level:\nWHIR‚Äôs arguments occupy 157 KiB vs STIR‚Äôs 160 KiB and FRI‚Äôs 306 KiB (1.95√ó better). WHIR‚Äôs verifier perform 2.7k hashes vs STIR‚Äôs 2.6k and FRI‚Äôs 5.6k (2.1√ó better). WHIR‚Äôs verifier runs in 1.0ms vs STIR‚Äôs 3.8ms and FRI‚Äôs 3.9ms (3.8√ó better). Applications We present a few applications that we believe WHIR is a natural candidate for.\nOn chain verification Currently, most onchain verification is done with Groth16 over a BN254 curve. The benefits of such verification is that the proof is constant size and verification is supposed to cheap, keeping both data availability (DA) costs and compute costs low. Currently, this verification costs ~280k gas . We believe that, as long as DA costs are low (as they currently are), WHIR can offer significantly lower compute costs for onchain proof verification (and we are working on a Solidity verifier to confirm this thesis). A rough back-of-the-envelope calculation: a WHIR verifier for a polynomial of size $2^{24}$ and rate $1/2$ performs around 1.5k hashes (using 100-bits of security to compare with BN254). Assuming the hash used is Keccak, and that each of these hashes is for Merkle tree verification (and thus hashes together 64 bytes), each of these hashes costs 48 gas. Thus, the cost of hash-verification is around 96k gas. Estimating the cost of the field operations is harder, but they tend account for a much smaller portion of the verification costs (on native experiments) compared to the hashing.\nRecursive verification Due to the small number of hashes, WHIR‚Äôs verifier (as STIR‚Äôs was) is a natural candidate for recursion. Again, let‚Äôs do some back-of-the-envelope calculation. At the 128-bit security level, for a computation of size $2^{28}$, starting with rate $1/2$, WHIR‚Äôs recursive circuit performs $3.4$k hashes. Assuming both use Poseidon hashing and that each hash contributes ~400 R1CS constraints, the WHIR‚Äôs recursive circuit size is approximately of size $2^{20}$. Then, running WHIR with even a large rate is a negligible cost (compared to the initial computation), leading to a tiny final proof. For example, running a computation of that size with rate $1/32$ gives a 64KiB proof in less than 3s (on my M1 Macbook), that verifies in less that $350¬µ$s while performing only 800 hashes.\nzkLogin Various blockchains such as Sui and Aptos have new onboarding and login strategy which make heavy use of zero-knowledge proofs. Currently, taking Sui‚Äôs zkLogin as an example, the final circuit is around the size of a million of constraints and is currently proven by using a Groth16 proof system. WHIR could be used instead, reducing both proving time and verification time (which now is native!).\nHigh-level overview We first introduce constrained Reed‚ÄìSolomon codes, then we describe the main protocol and sketch its complexity.\nConstrained Reed‚ÄìSolomon codes WHIR is an expressive IOPP for a generic class of codes, that we call constrained Reed‚ÄìSolomon codes. Recall that the Reed‚ÄìSolomon code over field $\\mathbb{F}$, domain $L \\subseteq \\mathbb{F}$ and rate $\\rho = 2^m/|L|$ is defined as $\\mathsf{RS}[\\mathbb{F}, L, m] = \\{ f: L \\to \\mathbb{F}: \\exists \\hat{p} \\in \\mathbb{F}^{\u003c 2^m}[X] : \\hat{p}(L) = f(L)\\}$. Equivalently, one can view a univariate polynomial of degree $2^m$ as a multilinear polynomial over $m$ variables, and one can recover evaluations of the former from the evaluations of the latter on points of the form $(x, x^2, \\dots, x^{2^{m-1}})$. Thus, we rewrite $\\mathsf{RS}[\\mathbb{F}, L, m] = \\{ f: L \\to \\mathbb{F}: \\exists \\hat{p} \\in \\mathbb{F}^{\u003c 2}[X_1, ‚Ä¶, X_m] \\text{ s.t. } \\forall x \\in L ; \\hat{p}(x, \\dots, x^{2^{m-1}}) = f(x) \\}$. For any codeword $f \\in \\mathsf{RS}[\\mathbb{F}, L, m]$, we let $\\hat{f}$ denote the corresponding multilinear polynomial.\nConstrained Reed‚ÄìSolomon codes are defined by a constraint, which consists of a weight polynomial $\\hat{w}\\in \\mathbb{F}[Z, X_1, \\dots, X_m]$ and of a target $\\sigma \\in \\mathbb{F}$:\n$$ \\mathsf{CRS}[\\mathbb{F}, L, m, \\hat{w}, \\sigma] := \\{ f \\in \\mathsf{RS}[\\mathbb{F}, L, m] : \\sum_{\\mathbf{b}} \\hat{w}(\\hat{f}(\\mathbf{b}), \\mathbf{b}) \\} $$\nNote, for example, that by setting $\\hat{w}(Z, X_1, \\dots, X_m) = Z \\cdot \\mathsf{eq}(\\mathbf{z}, X_1, \\dots, X_m)$2 for some $\\mathbf{z} \\in \\sigma$ the constrained code exactly captures Reed‚ÄìSolomon codewords whose corresponding polynomial evaluates to $\\sigma$ at $\\mathbf{z}$.\nWHIR WHIR is an IOPP of proximity for constrained Reed‚ÄìSolomon codes. WHIR makes use of both the sumcheck techniques introduced in [ZFC24]3 and of the rate improvement techniques in [ACFY24]4.\nLet $k$ be a folding parameter, $\\delta \\in (0, 1 - \\rho)$5 a proximity parameter and $t$ a repetition parameter. A WHIR iteration reduces testing that $$ f \\in \\mathsf{CRS}[\\mathbb{F}, L, m, \\hat{w}, \\sigma] $$ to testing that $$ g \\in \\mathsf{CRS}[\\mathbb{F}, L^2, m - k, \\hat{w}‚Äô, \\sigma‚Äô],$$ for related $g, \\hat{w}‚Äô, \\sigma‚Äô$.\nFurther, if $f$ was $\\delta$-far from the original code, then, unless with probability approximately $(1 - \\delta)^t$, $g$ will be $(1 - \\rho‚Äô)$-far from the smaller code, where $\\rho‚Äô = 2^{1 - k} \\cdot \\rho$ is the code of this new code.\nThe iteration consists of the following steps:\nSumcheck rounds. The prover and the verifier engage in $k$ rounds of the sumcheck protocol for the claim $$ \\sum_{\\mathbf{b}} \\hat{w}(\\hat{f}(\\mathbf{b}), \\mathbf{b}) = \\sigma $$ where $\\hat{f}$ is the multilinear polynomial associated with $f$. At the end of the interaction, the prover will have sent quadratic $(\\hat{h}_1, \\dots, \\hat{h}_k)$ while the verifier will have sampled randomness $(\\alpha_{1},\\dots,\\alpha_{k})\\in \\mathbb{F}^k$. This reduces the initial claim to the simpler claim $$ \\sum_{\\mathbf{b}} \\hat{w}(\\hat{f}(\\alpha_1, \\dots, \\alpha_k, \\mathbf{b}), \\alpha_1, \\dots, \\alpha_k, \\mathbf{b}) = \\sigma $$ Claimed codeword. The prover sends a function $g: L^2 \\to \\mathbb{F}$. In the honest case, $g$ is the codeword associated to the $(m - k)$-variate multilinear polynomial $\\hat{f}(\\alpha_1, \\dots, \\alpha_k, \\cdot)$. Out-of-domain sample. The verifier samples and sets $z_0 \\gets \\mathbb{F}$. We let $\\mathbf{z}_0 := (z_0, \\dots, z_0^{2^{m-1}})$. Out-of-domain answer. The prover replies with $y_0$. In the honest case $y_0 := \\hat{g}(\\mathbf{z}_0)$. Shift queries and combination randomness. For every $i \\in [t]$, the verifier samples $z_i \\gets L^{2^k}$, computes $y_i := \\mathsf{Fold}(f, (\\alpha_1, \\dots, \\alpha_k))(z_i)$ by querying $f$6, and sets $\\mathbf{z}_i := (z_i, \\dots, z_i^{2^{m-1}})$. It then samples $\\xi \\gets \\mathbb{F}$ and sends $z_1, \\dots, z_t, \\xi$ to the prover. Recursive claim. Prover and verifier set: $$ \\hat{w}‚Äô(Z, \\mathbf{X}) := \\hat{w}(Z, \\alpha_1, \\dots, \\alpha_k, \\mathbf{X}) + Z \\cdot \\sum_{i = 0}^t \\xi^{i + 1} \\cdot \\mathsf{eq}(\\mathbf{X}, \\mathbf{z}_i) $$ and $$ \\sigma‚Äô := \\hat{h}_k(\\alpha_k) + \\sum_{i = 0}^t \\xi^{i + 1} y_i $$ At each iteration, the verifier performs exactly $t$ queries to the function being tested each of which reads $2^k$ field elements, performs $O(k)$ field operations to check the sumcheck claims and $O(t \\cdot 2^k)$ fops to compute the folds7. Additionally, in the final iteration the verifier will have to evaluate a final weight polynomial $\\hat{w}$ which contains $O(\\sum_i t_i)$ equality polynomials over at most $m$ variables (plus the initial weight).\nThe soundness analysis relies on a new property of Reed‚ÄìSolomon codes, that we call mutual correlated agreement. This is a strenghtening of correlated agreement [BCIKS20]8, which we show holds in the unique decoding regime. We are confident to conjecture that it also holds in the list-decoding regime. Further, we believe that WHIR can be proven sound from weaker assumptions still. We refer the reader to the paper for more details.\nBenchmarks We implemented WHIR in Rust, and evaluated its performance. Our code can be found at WizardOfMenlo/whir . We thank in particular Remco Bloemen for his invaluable help in optimizing the prover performance of WHIR.\nWe present some of our comparisons here, and refer the reader to Section 6 of the paper for full details.\nComparison with BaseFold WHIR achieves significantly smaller argument size compared to BaseFold[ZFC24]3, while achieving significantly faster proving and verification. In part, this is due to WHIR having a more optimized implementation.\nComparison with other PCSes WHIR achieves the fastest verification time of any PCS know thus far. In particular, this includes schemes such as PST and KZG which rely on both a trusted setup and on pairings of elliptic curves.\nComparision with LDTs Finally, WHIR achieves state-of-the-art argument size, verifier hash-complexity among low-degree tests, while not compromising prover performance and achieving best-in-class verifier performance.\nCitation G. Arnon, A. Chiesa, G. Fenzi, E. Yogev. ‚ÄúWHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification‚Äù. Cryptology ePrint Archive, Paper 2024/XXX. Available at: https://ia.cr/2024/1586 .\n@misc{ArnonCFY, author = {Gal Arnon and Alessandro Chiesa and Giacomo Fenzi and Eylon Yogev}, title = {WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification}, howpublished = {Cryptology ePrint Archive, Paper 2024/1586}, year = {2024}, note = {\\url{https://eprint.iacr.org/2024/1586}}, url = {https://eprint.iacr.org/2024/1586} } Related material constrained Reed‚ÄìSolomon codes are a generalization of Reed‚ÄìSolomon codes which we introduce later.¬†‚Ü©Ô∏é\n$\\mathsf{eq}(X_1, \\dots, X_m, Y_1, \\dots, Y_m) = \\prod_{i = 1}^m (X_i \\cdot Y_i + (1 - X_i) \\cdot(1 - Y_i))$.¬†‚Ü©Ô∏é\n[ZCF24] Hadas Zeilberger, Binyi Chen, and Ben Fisch. ‚ÄúBaseFold: Efficient Field-Agnostic Poly- nomial Commitment Schemes from Foldable Codes‚Äù. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ‚Äô24¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é\n[ACFY24] Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev. ‚ÄúSTIR: Reed‚ÄìSolomon Proximity Testing with Fewer Queries‚Äù. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ‚Äô24. CRYPTO ‚Äô24.¬†‚Ü©Ô∏é¬†‚Ü©Ô∏é\nhere and in other places, proximity parameter of the form $1 - \\rho$ are obtained via an appropriate conjecture on list-decoding of Reed‚ÄìSolomon codes up to capacity. Provable bounds are obtained by replacing these with $1 - \\sqrt{\\rho}$ wherever they appear.¬†‚Ü©Ô∏é\nthe folding herein is the same as in FRI [BBHR18]9 and STIR [ACFY24]4, and we assume familiarity with it.¬†‚Ü©Ô∏é\ntraditionally, this step would require $O(t \\cdot k \\cdot 2^k)$ fops, but we present an optimization to avoid the quasilinear cost in $k$, see paper and blurb .¬†‚Ü©Ô∏é\n[BCIKS20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. ‚ÄúProximity Gaps for Reed‚ÄìSolomon Codes‚Äù. In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science. FOCS ‚Äô20. 2020.¬†‚Ü©Ô∏é\n[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. ‚ÄúFast Reed‚ÄìSolomon Interactive Oracle Proofs of Proximity‚Äù. In: Proceedings of the 45th International Colloquium on Automata, Languages and Programming. ICALP ‚Äô18. 2018,¬†‚Ü©Ô∏é\n","wordCount":"1960","inLanguage":"en","datePublished":"2024-09-27T00:00:00Z","dateModified":"2024-09-27T00:00:00Z","author":{"@type":"Person","name":"Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/papers/whir/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification</h1><div class=post-meta><span title='2024-09-27 00:00:00 +0000 UTC'>September 2024</span>&nbsp;&#183;&nbsp;Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2024/1586 rel="noopener noreferrer" target=_blank>ePrint: 2024/1586</a></div></header><div class=post-content><p>This blog-post is a short introduction to our new work: &ldquo;WHIR: Reed&ndash;Solomon Proximity Testing with Super-Fast Verification&rdquo;. This is joint work with <a href=https://galarnon42.github.io/ target=_blank>Gal Arnon,</a>
<a href=https://ic-people.epfl.ch/~achiesa/ target=_blank>Alessandro Chiesa,</a>
and <a href=https://www.eylonyogev.com/about target=_blank>Eylon Yogev,</a>
and the full version is <a href=https://eprint.iacr.org/2024/1586 target=_blank>available on ePrint</a>
. Code is also available at <a href=https://github.com/WizardOfMenlo/whir target=_blank>WizardOfMenlo/whir.</a></p><h1 id=whir->WHIR üå™Ô∏è</h1><p>We present WHIR (Weights Help Improving Rate), a concretely efficient IOPP for constrained Reed&ndash;Solomon codes<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>WHIR is both an IOPP for Reed&ndash;Solomon codes and a multilinear polynomial commitment scheme (PCS), and achieves the <em>fastest verification</em> speed of <em>any</em> such scheme, even including univariate PCS with trusted setup.
It does so while mantaining state-of-the-art argument size and verifier hash complexity for hash-based schemes, requiring only transparent setup and guaranteeing post-quantum security.</p><p>As a multilinear and univariate PCS, WHIR achieve by far the smallest verification time across all scheme that we tested.
Taking $d = 2^{24}$ as an example:</p><ul><li>At the 100-bit security level, a WHIR proof verification takes between 610Œºs (with $\rho = 1/2$) to 290Œºs (with $\rho = 1/16$). This is a speedup of between <strong>5700√ó-12000√ó</strong> against Brakedown, <strong>1200√ó- 2500√ó</strong> against Ligero, <strong>164√ó-345√ó</strong> against Hyrax, <strong>13√ó-27√ó</strong> against PST and <strong>4.0√ó-8.3√ó</strong> against KZG.</li><li>At the 128-bit security level, a WHIR proof verification takes between 1.4ms to 700Œºs achieving a speedup of between <strong>2600√ó-5300√ó</strong> against Brakedown, <strong>535√ó-1100√ó</strong> against Ligero, <strong>93√ó-186√ó</strong> against Greyhound, <strong>108√ó-216√ó</strong> against Hyrax, <strong>7√ó-14√ó</strong> against PST and <strong>2.6√ó-5.2√ó</strong> against KZG.</li></ul><p>As a hash-based multilinear PCS, WHIR compares favourably to BaseFold in (i) argument size (ii) verifier time (iii) verifier hashes.</p><p>Taking $d = 2^{24}$ and $\rho = 1/2$ as an example, at the 100-bit security level:</p><ul><li>WHIR&rsquo;s arguments are 101 KiB vs BaseFold&rsquo;s 7.95 MiB (<strong>74√ó better</strong>).</li><li>WHIR&rsquo;s verifier runs in 610Œºs vs BaseFold&rsquo;s 24ms (<strong>39√ó better</strong>).</li></ul><p>As a low-degree test, WHIR achieves best-in-class verifier time, while mantaining state-of-the-art argument size and verifier hash complexity.
Taking $d = 2^{24}$ and $\rho = 1/2$ as an example, at the 128-bit security level:</p><ul><li>WHIR&rsquo;s arguments occupy 157 KiB vs STIR&rsquo;s 160 KiB and FRI&rsquo;s 306 KiB (<strong>1.95√ó better</strong>).</li><li>WHIR&rsquo;s verifier perform 2.7k hashes vs STIR&rsquo;s 2.6k and FRI&rsquo;s 5.6k (<strong>2.1√ó better</strong>).</li><li>WHIR&rsquo;s verifier runs in 1.0ms vs STIR&rsquo;s 3.8ms and FRI&rsquo;s 3.9ms (<strong>3.8√ó better</strong>).</li></ul><hr><h2 id=applications>Applications</h2><p>We present a few applications that we believe WHIR is a natural candidate for.</p><h3 id=on-chain-verification>On chain verification</h3><p>Currently, most onchain verification is done with Groth16 over a BN254 curve. The benefits of such verification is that the proof is constant size and verification is supposed to cheap, keeping both data availability (DA) costs and compute costs low. Currently, this verification costs <a href=https://sepolia.etherscan.io/tx/0x9db0680f9164e045cf1cbf6f6c3a1afff204e2dc6c5af9582fb2ba89ef3e2b12 target=_blank>~280k gas</a>
.
We believe that, as long as DA costs are low (as they currently are), WHIR can offer significantly lower compute costs for onchain proof verification (and we are working on a Solidity verifier to confirm this thesis).
A rough back-of-the-envelope calculation: a WHIR verifier for a polynomial of size $2^{24}$ and rate $1/2$ performs around 1.5k hashes (using 100-bits of security to compare with BN254). Assuming the hash used is Keccak, and that each of these hashes is for Merkle tree verification (and thus hashes together 64 bytes), each of these hashes costs 48 gas. Thus, the cost of hash-verification is around <strong>96k gas</strong>. Estimating the cost of the field operations is harder, but they tend account for a much smaller portion of the verification costs (on native experiments) compared to the hashing.</p><h3 id=recursive-verification>Recursive verification</h3><p>Due to the small number of hashes, WHIR&rsquo;s verifier (as STIR&rsquo;s was) is a natural candidate for recursion. Again, let&rsquo;s do some back-of-the-envelope calculation. At the 128-bit security level, for a computation of size $2^{28}$, starting with rate $1/2$, WHIR&rsquo;s recursive circuit performs $3.4$k hashes. Assuming both use Poseidon hashing and that each hash contributes ~400 R1CS constraints, the WHIR&rsquo;s recursive circuit size is approximately of size $2^{20}$. Then, running WHIR with even a large rate is a negligible cost (compared to the initial computation), leading to a tiny final proof. For example, running a computation of that size with rate $1/32$ gives a 64KiB proof in less than 3s (on my M1 Macbook), that verifies in less that $350¬µ$s while performing only 800 hashes.</p><h3 id=zklogin>zkLogin</h3><p>Various blockchains such as <a href=https://sui.io/zklogin target=_blank>Sui</a>
and <a href=https://aptos.dev/en/build/guides/aptos-keyless/how-keyless-works target=_blank>Aptos</a>
have new onboarding and login strategy which make heavy use of zero-knowledge proofs. Currently, taking Sui&rsquo;s zkLogin as an example, the final circuit is around the size of a million of constraints and is currently proven by using a Groth16 proof system. WHIR could be used instead, reducing both proving time and verification time (which now is native!).</p><hr><h1 id=high-level-overview>High-level overview</h1><p>We first introduce constrained Reed&ndash;Solomon codes, then we describe the main protocol and sketch its complexity.</p><h2 id=constrained-reed--solomon-codes>Constrained Reed&ndash;Solomon codes</h2><p>WHIR is an expressive IOPP for a generic class of codes, that we call constrained Reed&ndash;Solomon codes.
Recall that the Reed&ndash;Solomon code over field $\mathbb{F}$, domain $L \subseteq \mathbb{F}$ and rate $\rho = 2^m/|L|$ is defined as $\mathsf{RS}[\mathbb{F}, L, m] = \{ f: L \to \mathbb{F}: \exists \hat{p} \in \mathbb{F}^{&lt; 2^m}[X] : \hat{p}(L) = f(L)\}$. Equivalently, one can view a univariate polynomial of degree $2^m$ as a multilinear polynomial over $m$ variables, and one can recover evaluations of the former from the evaluations of the latter on points of the form $(x, x^2, \dots, x^{2^{m-1}})$.
Thus, we rewrite $\mathsf{RS}[\mathbb{F}, L, m] = \{ f: L \to \mathbb{F}: \exists \hat{p} \in \mathbb{F}^{&lt; 2}[X_1, &mldr;, X_m] \text{ s.t. } \forall x \in L ; \hat{p}(x, \dots, x^{2^{m-1}}) = f(x) \}$.
For any codeword $f \in \mathsf{RS}[\mathbb{F}, L, m]$, we let $\hat{f}$ denote the corresponding multilinear polynomial.</p><p>Constrained Reed&ndash;Solomon codes are defined by a constraint, which consists of a weight polynomial $\hat{w}\in \mathbb{F}[Z, X_1, \dots, X_m]$ and of a target $\sigma \in \mathbb{F}$:</p><p>$$ \mathsf{CRS}[\mathbb{F}, L, m, \hat{w}, \sigma] := \{ f \in \mathsf{RS}[\mathbb{F}, L, m] : \sum_{\mathbf{b}} \hat{w}(\hat{f}(\mathbf{b}), \mathbf{b}) \} $$</p><p>Note, for example, that by setting $\hat{w}(Z, X_1, \dots, X_m) = Z \cdot \mathsf{eq}(\mathbf{z}, X_1, \dots, X_m)$<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> for some $\mathbf{z} \in \sigma$ the constrained code exactly captures Reed&ndash;Solomon codewords whose corresponding polynomial evaluates to $\sigma$ at $\mathbf{z}$.</p><hr><h2 id=whir>WHIR</h2><p>WHIR is an IOPP of proximity for constrained Reed&ndash;Solomon codes. WHIR makes use of both the sumcheck techniques introduced in [ZFC24]<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> and of the rate improvement techniques in [ACFY24]<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><p>Let $k$ be a folding parameter, $\delta \in (0, 1 - \rho)$<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> a proximity parameter and $t$ a repetition parameter. A WHIR iteration reduces testing that
$$ f \in \mathsf{CRS}[\mathbb{F}, L, m, \hat{w}, \sigma] $$
to testing that
$$ g \in \mathsf{CRS}[\mathbb{F}, L^2, m - k, \hat{w}&rsquo;, \sigma&rsquo;],$$
for related $g, \hat{w}&rsquo;, \sigma&rsquo;$.</p><p>Further, if $f$ was $\delta$-far from the original code, then, unless with probability approximately $(1 - \delta)^t$, $g$ will be $(1 - \rho&rsquo;)$-far from the smaller code, where $\rho&rsquo; = 2^{1 - k} \cdot \rho$ is the code of this new code.</p><p>The iteration consists of the following steps:</p><ol><li><strong>Sumcheck rounds.</strong> The prover and the verifier engage in $k$ rounds of the sumcheck protocol for the claim
$$ \sum_{\mathbf{b}} \hat{w}(\hat{f}(\mathbf{b}), \mathbf{b}) = \sigma $$
where $\hat{f}$ is the multilinear polynomial associated with $f$.
At the end of the interaction, the prover will have sent quadratic $(\hat{h}_1, \dots, \hat{h}_k)$ while the verifier will have sampled randomness $(\alpha_{1},\dots,\alpha_{k})\in \mathbb{F}^k$. This reduces the initial claim to the simpler claim
$$ \sum_{\mathbf{b}} \hat{w}(\hat{f}(\alpha_1, \dots, \alpha_k, \mathbf{b}), \alpha_1, \dots, \alpha_k, \mathbf{b}) = \sigma $$</li><li><strong>Claimed codeword.</strong> The prover sends a function $g: L^2 \to \mathbb{F}$. In the honest case, $g$ is the codeword associated to the $(m - k)$-variate multilinear polynomial $\hat{f}(\alpha_1, \dots, \alpha_k, \cdot)$.</li><li><strong>Out-of-domain sample.</strong> The verifier samples and sets $z_0 \gets \mathbb{F}$. We let $\mathbf{z}_0 := (z_0, \dots, z_0^{2^{m-1}})$.</li><li><strong>Out-of-domain answer.</strong> The prover replies with $y_0$. In the honest case $y_0 := \hat{g}(\mathbf{z}_0)$.</li><li><strong>Shift queries and combination randomness.</strong> For every $i \in [t]$, the verifier samples $z_i \gets L^{2^k}$, computes $y_i := \mathsf{Fold}(f, (\alpha_1, \dots, \alpha_k))(z_i)$ by querying $f$<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>, and sets $\mathbf{z}_i := (z_i, \dots, z_i^{2^{m-1}})$. It then samples $\xi \gets \mathbb{F}$ and sends $z_1, \dots, z_t, \xi$ to the prover.</li><li><strong>Recursive claim.</strong> Prover and verifier set:
$$ \hat{w}&rsquo;(Z, \mathbf{X}) := \hat{w}(Z, \alpha_1, \dots, \alpha_k, \mathbf{X}) + Z \cdot \sum_{i = 0}^t \xi^{i + 1} \cdot \mathsf{eq}(\mathbf{X}, \mathbf{z}_i) $$
and
$$ \sigma&rsquo; := \hat{h}_k(\alpha_k) + \sum_{i = 0}^t \xi^{i + 1} y_i $$</li></ol><p>At each iteration, the verifier performs exactly $t$ queries to the function being tested each of which reads $2^k$ field elements, performs $O(k)$ field operations to check the sumcheck claims and $O(t \cdot 2^k)$ fops to compute the folds<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. Additionally, in the final iteration the verifier will have to evaluate a final weight polynomial $\hat{w}$ which contains $O(\sum_i t_i)$ equality polynomials over at most $m$ variables (plus the initial weight).</p><p>The soundness analysis relies on a new property of Reed&ndash;Solomon codes, that we call <strong>mutual correlated agreement</strong>. This is a strenghtening of correlated agreement [BCIKS20]<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>, which we show holds in the unique decoding regime. We are confident to conjecture that it also holds in the list-decoding regime. Further, we believe that WHIR can be proven sound from weaker assumptions still.
We refer the reader to the paper for more details.</p><hr><h2 id=benchmarks>Benchmarks</h2><p>We implemented WHIR in Rust, and evaluated its performance. Our code can be found at <a href=https://github.com/WizardOfMenlo/whir target=_blank>WizardOfMenlo/whir</a>
. <em>We thank in particular <a href=https://xn--2-umb.com/about/ target=_blank>Remco Bloemen</a>
for his invaluable help in optimizing the prover performance of WHIR</em>.</p><p>We present some of our comparisons here, and refer the reader to Section 6 of the paper for full details.</p><h3 id=comparison-with-basefold>Comparison with BaseFold</h3><p><img loading=lazy src=basefold_compare.png alt></p><p>WHIR achieves significantly smaller argument size compared to BaseFold[ZFC24]<sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, while achieving significantly faster proving and verification. In part, this is due to WHIR having a more optimized implementation.</p><h3 id=comparison-with-other-pcses>Comparison with other PCSes</h3><p><img loading=lazy src=kzg_compare.png alt>
WHIR achieves the fastest verification time of <strong>any</strong> PCS know thus far. In particular, this includes schemes such as PST and KZG which rely on both a trusted setup and on pairings of elliptic curves.</p><h2 id=comparision-with-ldts>Comparision with LDTs</h2><p><img loading=lazy src=ldt_compare.png alt>
Finally, WHIR achieves state-of-the-art argument size, verifier hash-complexity among low-degree tests, while not compromising prover performance and achieving best-in-class verifier performance.</p><hr><h5 id=citation>Citation</h5><p>G. Arnon, A. Chiesa, G. Fenzi, E. Yogev. &ldquo;<em>WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification</em>&rdquo;. Cryptology ePrint Archive, Paper 2024/XXX. Available at: <a href=https://ia.cr/2024/1586 target=_blank>https://ia.cr/2024/1586</a>
.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-BibTeX data-lang=BibTeX><span style=display:flex><span><span style=color:#0a0;text-decoration:underline>@misc</span>{ArnonCFY,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>author</span>       = <span style=color:#a50>{Gal Arnon and Alessandro Chiesa and Giacomo Fenzi and Eylon Yogev}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>title</span>        = <span style=color:#a50>{WHIR: Reed‚ÄìSolomon Proximity Testing with Super-Fast Verification}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>howpublished</span> = <span style=color:#a50>{Cryptology ePrint Archive, Paper 2024/1586}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>year</span>         = <span style=color:#a50>{2024}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>note</span>         = <span style=color:#a50>{\url{https://eprint.iacr.org/2024/1586}}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>url</span>          = <span style=color:#a50>{https://eprint.iacr.org/2024/1586}</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h5 id=related-material>Related material</h5><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>constrained Reed&ndash;Solomon codes are a generalization of Reed&ndash;Solomon codes which we introduce later.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>$\mathsf{eq}(X_1, \dots, X_m, Y_1, \dots, Y_m) = \prod_{i = 1}^m (X_i \cdot Y_i + (1 - X_i) \cdot(1 - Y_i))$.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>[ZCF24] Hadas Zeilberger, Binyi Chen, and Ben Fisch. ‚ÄúBaseFold: Efficient Field-Agnostic Poly- nomial Commitment Schemes from Foldable Codes‚Äù. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ‚Äô24&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>[ACFY24] Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, Eylon Yogev. ‚ÄúSTIR: Reed&ndash;Solomon Proximity Testing with Fewer Queries‚Äù. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ‚Äô24. CRYPTO ‚Äô24.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>here and in other places, proximity parameter of the form $1 - \rho$ are obtained via an appropriate conjecture on list-decoding of Reed&ndash;Solomon codes up to capacity. Provable bounds are obtained by replacing these with $1 - \sqrt{\rho}$ wherever they appear.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>the folding herein is the same as in FRI [BBHR18]<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> and STIR [ACFY24]<sup id=fnref1:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, and we assume familiarity with it.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>traditionally, this step would require $O(t \cdot k \cdot 2^k)$ fops, but we present an optimization to avoid the quasilinear cost in $k$, see paper and <a href=/blurbs/whir-folding>blurb</a>
.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>[BCIKS20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. ‚ÄúProximity Gaps for Reed‚ÄìSolomon Codes‚Äù. In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science. FOCS ‚Äô20. 2020.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. ‚ÄúFast Reed‚ÄìSolomon Interactive Oracle Proofs of Proximity‚Äù. In: Proceedings of the 45th International Colloquium on Automata, Languages and Programming. ICALP ‚Äô18. 2018,&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/hashes/>hashes</a></li><li><a href=https://wizardofmenlo.github.io/tags/concrete/>concrete</a></li><li><a href=https://wizardofmenlo.github.io/tags/theory/>theory</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>