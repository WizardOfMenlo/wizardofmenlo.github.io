<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency | Giacomo's Blog</title><meta name=keywords content="lattices,polynomial-commitments,theory"><meta name=description content="In this paper, we introduce the powerBASIS assumption, and use it construct quasi-succinct polynomial commitment schemes from lattices."><meta name=author content="Giacomo Fenzi, Hossein Moghaddas, Ngoc Khanh Nguyen"><link rel=canonical href=https://wizardofmenlo.github.io/papers/towards-pcs/><link crossorigin=anonymous href=/assets/css/stylesheet.5c3d2aa85a103c2d32fb4f6cbe26e29098f291f6fedf6b1d5b502c91573ae1ce.css integrity="sha256-XD0qqFoQPC0y+09svibikJjykfb+32sdW1AskVc64c4=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency"><meta property="og:description" content="In this paper, we introduce the powerBASIS assumption, and use it construct quasi-succinct polynomial commitment schemes from lattices."><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/papers/towards-pcs/"><meta property="article:section" content="papers"><meta property="article:published_time" content="2023-06-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency"><meta name=twitter:description content="In this paper, we introduce the powerBASIS assumption, and use it construct quasi-succinct polynomial commitment schemes from lattices."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Papers","item":"https://wizardofmenlo.github.io/papers/"},{"@type":"ListItem","position":2,"name":"Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency","item":"https://wizardofmenlo.github.io/papers/towards-pcs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency","name":"Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency","description":"In this paper, we introduce the powerBASIS assumption, and use it construct quasi-succinct polynomial commitment schemes from lattices.","keywords":["lattices","polynomial-commitments","theory"],"articleBody":"In this blog-post, I will be taking a look at my recent work with Hossein Moghaddas and Ngoc Khanh Nguyen, full version . We extend the vector commitment scheme of [WW23]1 with an evaluation proof, and achieve a lattice-based polynomial commitment scheme with polylogarithmic proof size and verifier complexity. We further investigate the applicability of our techniques to the Polynomial IOP of [Marlin]2, show that our scheme is easily batchable and more!\nPolynomial Commitments A polynomial commitment scheme is a natural generalization of a vector commitment scheme, in which a party is able to commit to a polynomial $f$, and later engage in a evaluation protocol to show that $f(u) = z$. In this work, we consider polynomials of bounded degree $d$ with coefficients over the polynomial ring $\\mathcal{R}_q$ (we also show to adapt this construction for polynomials in $\\mathbb{F}^{\\leq d}[X]$, but details are left for the full version).\nThe interface of a polynomial commitment scheme follows partially that of standard commitmentscheme:\n$\\mathsf{Setup}(1^\\lambda) \\to (\\mathsf{pk}, \\mathsf{vk})$ takes a security parameter and outputs a proving and a verification key. $\\mathsf{Com}(\\mathsf{pk}, f) \\to (\\sigma, \\mathsf{aux})$ takes a proving key and a polynomial $f$ and outputs a commitment $\\sigma$ and auxiliary decommitment information $\\mathsf{aux}$. $\\mathsf{Open}(\\mathsf{vk}, f, \\sigma, \\mathsf{aux})$ checks whether $(\\sigma, \\mathsf{aux})$ are a valid commitment-opening pair for $f$. Furthermore, we extend the interface with an evaluation protocol between a prover and a verifier $\\mathbf{P}, \\mathbf{V}$. We denote the protocol as $\\langle \\mathbf{P}(\\mathsf{pk}, f, \\mathsf{aux}), \\mathbf{V}(\\mathsf{vk}) \\rangle(\\sigma, u, v)$.\nThe properties that we require from a polynomial commitment scheme are:\nCompleteness of the commitment scheme: If $\\mathsf{pk}, \\mathsf{vk}, \\sigma, \\mathsf{aux} $ are honestly generated (w.r.t to $f$), then $\\mathsf{Open}(\\mathsf{vk}, f, \\sigma, \\mathsf{aux}) = 1$. Binding of the commitment scheme: The probability that an efficient adversary can find $\\sigma, f,g, \\mathsf{aux}_f, \\mathsf{aux_g}$ such that $\\mathsf{Open}(\\mathsf{vk}, f, \\sigma, \\mathsf{aux}_f) = 1 = \\mathsf{Open}(\\mathsf{vk}, g, \\sigma, \\mathsf{aux}_g)$ is negligible. Evaluation completeness: If $f(u) = z$, the evaluation protocol will accept. Evaluation knowledge-soundness: There exists an efficient extractor that, if a malicous prover is able to make the verifier accept with non-negligible probability, is able to extract a polynomial $f$ and an opening $\\mathsf{aux}$ such that $f(u) = z$ and $\\mathsf{Open}(\\mathsf{vk}, f, \\sigma, \\mathsf{aux}_f) = 1$. In the paper, we also consider hiding, but in the interest of space we avoid this here.\nWeeWu Commitments Our starting point is the commitment scheme introduced in [WW23]1. Their commitments relies on the BASIS assumption (Basis-Augmented Short Integer Solution). It roughly states that an adversary that is given access to a random matrix $\\mathbf{A}$, should not be able to find a short vector $\\mathbf{v}$ such that $\\mathbf{A}\\mathbf{v} = 0$ even when given access to a trapdoor to sample short preimages of a matrix $\\mathbf{B}$ related to $\\mathbf{A}$. In their work, the matrix $\\mathbf{B}$ is defined as $$\\begin{bmatrix}\\mathbf{A}_0 \u0026\u0026\u0026 - \\mathbf{G}\\\\ \u0026 \\ddots \u0026 \u0026 \\\\ \u0026 \u0026 \\mathbf{A}_d \u0026 - \\mathbf{G} \\end{bmatrix}$$ where $\\mathbf{A}_i = \\mathbf{W}_i \\mathbf{A}$ for $\\mathbf{W_i}$ random invertible matrices and $\\mathbf{G}$ the gadget matrix of [MP12]3. We extend this to two new assumptions, the powerBASIS and PRISIS assumptions. Roughly, we introduce more structure in the $\\mathbf{W}_i$. In powerBASIS, we let $\\mathbf{W}_i = \\mathbf{W}^{i}$, while in PRISIS we set $\\mathbf{W}_i = w^{i} \\mathbf{I}$. With this added structure, the commitment scheme that we construct is exactly as in [WW23] (here we present the powerBASIS version). Namely:\n$\\mathsf{Setup}(1^\\lambda) \\to (\\mathsf{pk}, \\mathsf{vk})$ samples $\\mathbf{A}, \\mathbf{W}$ and uses [MP12]3 sampling to construct a trapdoor $\\mathbf{T}$ of $\\mathbf{B}$. The verification key consists of $\\mathbf{A}, \\mathbf{W}$ and the proving key additionally contains $\\mathbf{T}$. $\\mathsf{Com}(\\mathsf{pk}, f) \\to (\\sigma, \\mathsf{aux})$ uses $\\mathbf{T}$ to sample short $\\mathbf{z_i}$ and $\\hat{\\mathbf{c}}$ such that $\\mathbf{B}[\\mathbf{z}_0, \\dots, \\mathbf{z}_d, \\hat{\\mathbf{c}}]^\\top = [-f_0 \\mathbf{W}^0 \\mathbf{e}_1, \\dots, - f_d \\mathbf{W}^d \\mathbf{e}_1]^\\top$, it then outputs $\\mathbf{c} := \\mathbf{G}\\hat{\\mathbf{c}}$ and $(\\mathbf{z}_i)$ as decommitment. $\\mathsf{Open}(\\mathsf{vk}, f, \\sigma, \\mathsf{aux})$ checks that the openings are indeed short, and that the equations are all satisfied: namely it checks that $$\\mathbf{A}\\mathbf{z}_i + f_i \\mathbf{e}_1 = \\mathbf{W}^{-i}\\mathbf{c} \\enspace.$$ We then show that this commitment scheme is binding (even with respect to relaxed openings, as customary in the lattice-world).\nEvaluation Proofs Now, our evaluation protocols are inspired partly by FRI (even though the setting and analysis are completely different). Suppose we aim to show that $f(u) = z$. We take our polynomial $f$ and write it as an odd an even part i.e.: $$f(X) = f_0(X^2) + Xf_1(X^2)$$ The prover then sends evaluations $z_0, z_1$ of $f_0, f_1$ on $u^2$. The verifier checks that $z_0 + u z_1 = z$ and sends a random challenge $\\alpha$ to the prover, and computes an updated commitment $\\mathbf{c}’ = (1 + \\alpha \\mathbf{W}^{-1}) \\mathbf{c}$ and a new verification key where $\\mathbf{W}’ = \\mathbf{W}^2$. The prover computes a new folded polynomial $g$ and updated opening as follows: $$g(X) = f_0(X) + \\alpha f_1(X), \\mathbf{s}_i = \\mathbf{z}_{2i} + \\alpha \\mathbf{z}_{2i+1}\\enspace.$$ The crucial observation is that the parties now can recurse on the claim that $g(u^2) = z_0 + \\alpha z_1$, which is about a polynomial of degree $d/2$. We recurse thus $\\log d$ times, until the prover can just send a constant sized opening. Note in particular that the additional structure of the powerBASIS construction allowed the verifier to efficiently construct a commitment to $g$ from one to $f$. In particular, note that $$\\mathbf{A}\\mathbf{s}_i + g_i \\mathbf{e}_1 = \\mathbf{A}\\mathbf{z}_{2i} + f_{2i}\\mathbf{e}_1 + \\alpha \\cdot ( \\mathbf{A}\\mathbf{z}_{2i+1} + f_{2i+1}\\mathbf{e}_1)$$ $$ = \\mathbf{W}^{-2i}\\mathbf{c} + \\alpha \\mathbf{W}^{-2i - 1}\\mathbf{c} = (\\mathbf{W}^2)^{-i} (1 + \\alpha \\mathbf{W}^{-1})\\mathbf{c}$$\nCrucially, compared to other protocols like lattice-bulletproofs, the extraction keeps the norm growth more manageable (at the cost of trusted setup), which should lead to more concretely efficient protocols. The details are in the paper, due to the requirement of a flurry of notation.\nNow, what is left to do is to manage the norm growth. We do this in two ways, which leads to two different protocols (with different tradeoff).\nBy selecting the challenge $\\alpha$ to be a (signed) monomial, we can ensure that the norm (here and in extraction) remains polynomial throught the $\\log d$ rounds of the protocol. This achieves a protocol with polylogarithmic communication and verifier complexity. However, since the challenge set is of size $\\mathrm{poly}(\\lambda)$, we obtain a non-negligible soundness error, which needs to be mitigated by parallel repetition, making the protocol unsuitable to be made non-interactive via Fiat-Shamir. Instead of folding the polynomial halfway, we can aim to fold it in $k$-parts, and sample from an exponentially sized set. The norm growth is then much higher, only making it affordable to run the protocol $\\log \\log d$ iterations. Choosing $k$ appropriately, we are able to obtain a protocol with negligible knowledge soundness error and verifier and communication complexity “quasi-polylogarithmic” $d^{1/\\log \\log d}$4. Instantiations We then looked at how the scheme could perform concretely. The repetition needed to achieve 128 bits of security in the monomial protocol yields very large proof sizes, in the order of hundred of MBs. The other protocol strikes much closer to concrete efficiency, achieving proof sizes around 6 MBs. We also looked at applying the two protocols in Marlin, making also use of some natural ways to aggregate our protocols. With this, we obtain a post-quantum zkSNARK for R1CS with proof size roughly 26 MBs. While this is still rather large, we are confident that further work will follow the asymptotic improvement to yield concretely efficient zkSNARKs from lattices.\nDrawbacks We inherit many of the drawbacks of [WW23]1, namely:\nThe size of the proving key is quadratic in $d$. We could not reduce powerBASIS (or original BASIS) to standard assumptions. We require a trusted setup. Furthermore, we our evaluations proof come with their own drawbacks:\nThe concrete proof sizes are rather large. We could not achieve a fully polylogarithmic protocol with negligible soundness error. We are confident that these drawbacks can be overcome in future work (wink 😉 ).\nConclusion Find the full version for the gory details!\nCitation G. Fenzi, H. Moghaddas, N. K. Nguyen. “Lattice-Based Polynomial Commitments: Towards Concrete and Asymptotical Efficiency”. Cryptology ePrint Archive, Paper 2023/846. Available at: https://ia.cr/2023/846 .\n@misc{FenziMN23, author = {Giacomo Fenzi and Hossein Moghaddas and Ngoc Khanh Nguyen}, title = {Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency}, howpublished = {Cryptology ePrint Archive, Paper 2023/846}, year = {2023}, note = {\\url{https://eprint.iacr.org/2023/846}}, url = {https://eprint.iacr.org/2023/846} } Related material H. Wee and D. J. Wu. “Succinct Vector, Polynomial, and Functional Commitments from Lattices”. In: EUROCRYPT (3). Vol. 14006. Lecture Notes in Computer Science. Full version: https://eprint.iacr.org/2022/1515 . Springer, 2023, pp. 385–416. ↩︎ ↩︎ ↩︎\nA. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 738–768. ↩︎\nD. Micciancio and C. Peikert. “Trapdoors for Lattices: Simpler, Tighter, Faster, Smaller”. In: EUROCRYPT. 2012, pp. 700–718. ↩︎ ↩︎\nWe called this quasi-polylogarithmic because it roughly sits between sublinear ($d^{1/t}$ for $t$ a constant) and polylogarithmic $\\mathrm{polylog}(d)$. ↩︎\n","wordCount":"1487","inLanguage":"en","datePublished":"2023-06-06T00:00:00Z","dateModified":"2023-06-06T00:00:00Z","author":{"@type":"Person","name":"Giacomo Fenzi, Hossein Moghaddas, Ngoc Khanh Nguyen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/papers/towards-pcs/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency</h1><div class=post-meta><span title='2023-06-06 00:00:00 +0000 UTC'>June 2023</span>&nbsp;&#183;&nbsp;Giacomo Fenzi, Hossein Moghaddas, Ngoc Khanh Nguyen&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2023/846 rel="noopener noreferrer" target=_blank>JoC 2024 - ArticCrypt 2025 - ePrint: 2023/846</a></div></header><div class=post-content><p>In this blog-post, I will be taking a look at my recent work with Hossein Moghaddas and Ngoc Khanh Nguyen, <a href=https://eprint.iacr.org/2023/846 target=_blank>full version</a>
.
We extend the vector commitment scheme of [WW23]<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> with an evaluation proof, and achieve a lattice-based polynomial commitment scheme with polylogarithmic proof size and verifier complexity.
We further investigate the applicability of our techniques to the Polynomial IOP of [Marlin]<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, show that our scheme is easily batchable and more!</p><hr><h2 id=polynomial-commitments>Polynomial Commitments</h2><p>A polynomial commitment scheme is a natural generalization of a vector commitment scheme, in which a party is able to commit to a polynomial $f$, and later engage in a <em>evaluation protocol</em> to show that $f(u) = z$. In this work, we consider polynomials of bounded degree $d$ with coefficients over the polynomial ring $\mathcal{R}_q$ (we also show to adapt this construction for polynomials in $\mathbb{F}^{\leq d}[X]$, but details are left for the full version).</p><p>The interface of a polynomial commitment scheme follows partially that of standard commitmentscheme:</p><ul><li>$\mathsf{Setup}(1^\lambda) \to (\mathsf{pk}, \mathsf{vk})$ takes a security parameter and outputs a proving and a verification key.</li><li>$\mathsf{Com}(\mathsf{pk}, f) \to (\sigma, \mathsf{aux})$ takes a proving key and a polynomial $f$ and outputs a commitment $\sigma$ and auxiliary decommitment information $\mathsf{aux}$.</li><li>$\mathsf{Open}(\mathsf{vk}, f, \sigma, \mathsf{aux})$ checks whether $(\sigma, \mathsf{aux})$ are a valid commitment-opening pair for $f$.</li></ul><p>Furthermore, we extend the interface with an evaluation protocol between a prover and a verifier $\mathbf{P}, \mathbf{V}$. We denote the protocol as $\langle \mathbf{P}(\mathsf{pk}, f, \mathsf{aux}), \mathbf{V}(\mathsf{vk}) \rangle(\sigma, u, v)$.</p><p>The properties that we require from a polynomial commitment scheme are:</p><ol><li>Completeness of the commitment scheme: If $\mathsf{pk}, \mathsf{vk}, \sigma, \mathsf{aux} $ are honestly generated (w.r.t to $f$), then $\mathsf{Open}(\mathsf{vk}, f, \sigma, \mathsf{aux}) = 1$.</li><li>Binding of the commitment scheme: The probability that an efficient adversary can find $\sigma, f,g, \mathsf{aux}_f, \mathsf{aux_g}$ such that $\mathsf{Open}(\mathsf{vk}, f, \sigma, \mathsf{aux}_f) = 1 = \mathsf{Open}(\mathsf{vk}, g, \sigma, \mathsf{aux}_g)$ is negligible.</li><li>Evaluation completeness: If $f(u) = z$, the evaluation protocol will accept.</li><li>Evaluation knowledge-soundness: There exists an efficient extractor that, if a malicous prover is able to make the verifier accept with non-negligible probability, is able to extract a polynomial $f$ and an opening $\mathsf{aux}$ such that $f(u) = z$ and $\mathsf{Open}(\mathsf{vk}, f, \sigma, \mathsf{aux}_f) = 1$.</li></ol><p>In the paper, we also consider hiding, but in the interest of space we avoid this here.</p><hr><h2 id=weewu-commitments>WeeWu Commitments</h2><p>Our starting point is the commitment scheme introduced in [WW23]<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Their commitments relies on the BASIS assumption (Basis-Augmented Short Integer Solution). It roughly states that an adversary that is given access to a random matrix $\mathbf{A}$, should not be able to find a short vector $\mathbf{v}$ such that $\mathbf{A}\mathbf{v} = 0$ even when given access to a trapdoor to sample short preimages of a matrix $\mathbf{B}$ related to $\mathbf{A}$. In their work, the matrix $\mathbf{B}$ is defined as $$\begin{bmatrix}\mathbf{A}_0 &&& - \mathbf{G}\\ & \ddots & & \\ & & \mathbf{A}_d & - \mathbf{G} \end{bmatrix}$$ where $\mathbf{A}_i = \mathbf{W}_i \mathbf{A}$ for $\mathbf{W_i}$ random invertible matrices and $\mathbf{G}$ the gadget matrix of [MP12]<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.
We extend this to two new assumptions, the powerBASIS and PRISIS assumptions. Roughly, we introduce more structure in the $\mathbf{W}_i$. In powerBASIS, we let $\mathbf{W}_i = \mathbf{W}^{i}$, while in PRISIS we set $\mathbf{W}_i = w^{i} \mathbf{I}$.
With this added structure, the commitment scheme that we construct is exactly as in [WW23] (here we present the powerBASIS version).
Namely:</p><ul><li>$\mathsf{Setup}(1^\lambda) \to (\mathsf{pk}, \mathsf{vk})$ samples $\mathbf{A}, \mathbf{W}$ and uses [MP12]<sup id=fnref1:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> sampling to construct a trapdoor $\mathbf{T}$ of $\mathbf{B}$. The verification key consists of $\mathbf{A}, \mathbf{W}$ and the proving key additionally contains $\mathbf{T}$.</li><li>$\mathsf{Com}(\mathsf{pk}, f) \to (\sigma, \mathsf{aux})$ uses $\mathbf{T}$ to sample short $\mathbf{z_i}$ and $\hat{\mathbf{c}}$ such that $\mathbf{B}[\mathbf{z}_0, \dots, \mathbf{z}_d, \hat{\mathbf{c}}]^\top = [-f_0 \mathbf{W}^0 \mathbf{e}_1, \dots, - f_d \mathbf{W}^d \mathbf{e}_1]^\top$, it then outputs $\mathbf{c} := \mathbf{G}\hat{\mathbf{c}}$ and $(\mathbf{z}_i)$ as decommitment.</li><li>$\mathsf{Open}(\mathsf{vk}, f, \sigma, \mathsf{aux})$ checks that the openings are indeed short, and that the equations are all satisfied: namely it checks that $$\mathbf{A}\mathbf{z}_i + f_i \mathbf{e}_1 = \mathbf{W}^{-i}\mathbf{c} \enspace.$$</li></ul><p>We then show that this commitment scheme is binding (even with respect to relaxed openings, as customary in the lattice-world).</p><hr><h2 id=evaluation-proofs>Evaluation Proofs</h2><p>Now, our evaluation protocols are inspired partly by FRI (even though the setting and analysis are completely different). Suppose we aim to show that $f(u) = z$.
We take our polynomial $f$ and write it as an odd an even part i.e.:
$$f(X) = f_0(X^2) + Xf_1(X^2)$$
The prover then sends evaluations $z_0, z_1$ of $f_0, f_1$ on $u^2$.
The verifier checks that $z_0 + u z_1 = z$ and sends a random challenge $\alpha$ to the prover, and computes an updated commitment $\mathbf{c}&rsquo; = (1 + \alpha \mathbf{W}^{-1}) \mathbf{c}$ and a new verification key where $\mathbf{W}&rsquo; = \mathbf{W}^2$.
The prover computes a new folded polynomial $g$ and updated opening as follows:
$$g(X) = f_0(X) + \alpha f_1(X), \mathbf{s}_i = \mathbf{z}_{2i} + \alpha \mathbf{z}_{2i+1}\enspace.$$
The crucial observation is that the parties now can recurse on the claim that $g(u^2) = z_0 + \alpha z_1$, which is about a polynomial of degree $d/2$. We recurse thus $\log d$ times, until the prover can just send a constant sized opening.
Note in particular that the additional structure of the powerBASIS construction allowed the verifier to efficiently construct a commitment to $g$ from one to $f$. In particular, note that
$$\mathbf{A}\mathbf{s}_i + g_i \mathbf{e}_1 = \mathbf{A}\mathbf{z}_{2i} + f_{2i}\mathbf{e}_1 + \alpha \cdot ( \mathbf{A}\mathbf{z}_{2i+1} + f_{2i+1}\mathbf{e}_1)$$
$$ = \mathbf{W}^{-2i}\mathbf{c} + \alpha \mathbf{W}^{-2i - 1}\mathbf{c} = (\mathbf{W}^2)^{-i} (1 + \alpha \mathbf{W}^{-1})\mathbf{c}$$</p><p>Crucially, compared to other protocols like lattice-bulletproofs, the extraction keeps the norm growth more manageable (at the cost of trusted setup), which should lead to more concretely efficient protocols. The details are in the paper, due to the requirement of a flurry of notation.</p><p>Now, what is left to do is to manage the norm growth. We do this in two ways, which leads to two different protocols (with different tradeoff).</p><ul><li>By selecting the challenge $\alpha$ to be a (signed) monomial, we can ensure that the norm (here and in extraction) remains polynomial throught the $\log d$ rounds of the protocol. This achieves a protocol with polylogarithmic communication and verifier complexity. However, since the challenge set is of size $\mathrm{poly}(\lambda)$, we obtain a non-negligible soundness error, which needs to be mitigated by parallel repetition, making the protocol unsuitable to be made non-interactive via Fiat-Shamir.</li><li>Instead of folding the polynomial halfway, we can aim to fold it in $k$-parts, and sample from an exponentially sized set. The norm growth is then much higher, only making it affordable to run the protocol $\log \log d$ iterations. Choosing $k$ appropriately, we are able to obtain a protocol with negligible knowledge soundness error and verifier and communication complexity &ldquo;quasi-polylogarithmic&rdquo; $d^{1/\log \log d}$<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</li></ul><hr><h2 id=instantiations>Instantiations</h2><p>We then looked at how the scheme could perform concretely. The repetition needed to achieve 128 bits of security in the monomial protocol yields very large proof sizes, in the order of hundred of MBs. The other protocol strikes much closer to concrete efficiency, achieving proof sizes around 6 MBs.
We also looked at applying the two protocols in Marlin, making also use of some natural ways to aggregate our protocols. With this, we obtain a post-quantum zkSNARK for R1CS with proof size roughly 26 MBs. While this is still rather large, we are confident that further work will follow the asymptotic improvement to yield concretely efficient zkSNARKs from lattices.</p><hr><h2 id=drawbacks>Drawbacks</h2><p>We inherit many of the drawbacks of [WW23]<sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, namely:</p><ul><li>The size of the proving key is quadratic in $d$.</li><li>We could not reduce powerBASIS (or original BASIS) to standard assumptions.</li><li>We require a trusted setup.</li></ul><p>Furthermore, we our evaluations proof come with their own drawbacks:</p><ul><li>The concrete proof sizes are rather large.</li><li>We could not achieve a fully polylogarithmic protocol with negligible soundness error.</li></ul><p>We are confident that these drawbacks can be overcome in future work (<a href=https://wizardofmenlo.github.io/papers/slap/>wink 😉</a>
).</p><hr><h2 id=conclusion>Conclusion</h2><p>Find the <a href=https://eprint.iacr.org/2023/846 target=_blank>full version</a>
for the gory details!</p><hr><h5 id=citation>Citation</h5><p>G. Fenzi, H. Moghaddas, N. K. Nguyen. &ldquo;<em>Lattice-Based Polynomial Commitments: Towards Concrete and Asymptotical Efficiency</em>&rdquo;. Cryptology ePrint Archive, Paper 2023/846. Available at: <a href=https://ia.cr/2023/846 target=_blank>https://ia.cr/2023/846</a>
.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-BibTeX data-lang=BibTeX><span style=display:flex><span><span style=color:#0a0;text-decoration:underline>@misc</span>{FenziMN23,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>author</span>       = <span style=color:#a50>{Giacomo Fenzi and Hossein Moghaddas and Ngoc Khanh Nguyen}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>title</span>        = <span style=color:#a50>{Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>howpublished</span> = <span style=color:#a50>{Cryptology ePrint Archive, Paper 2023/846}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>year</span>         = <span style=color:#a50>{2023}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>note</span>         = <span style=color:#a50>{\url{https://eprint.iacr.org/2023/846}}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>url</span>          = <span style=color:#a50>{https://eprint.iacr.org/2023/846}</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h5 id=related-material>Related material</h5><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>H. Wee and D. J. Wu. &ldquo;Succinct Vector, Polynomial, and Functional Commitments from Lattices&rdquo;. In: EUROCRYPT (3). Vol. 14006. Lecture Notes in Computer Science. Full version: <a href=https://eprint.iacr.org/2022/1515 target=_blank>https://eprint.iacr.org/2022/1515</a>
. Springer, 2023, pp. 385–416.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. &ldquo;Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS&rdquo;. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 738–768.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>D. Micciancio and C. Peikert. &ldquo;Trapdoors for Lattices: Simpler, Tighter, Faster, Smaller&rdquo;. In: EUROCRYPT. 2012, pp. 700–718.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>We called this quasi-polylogarithmic because it roughly sits between sublinear ($d^{1/t}$ for $t$ a constant) and polylogarithmic $\mathrm{polylog}(d)$.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/lattices/>lattices</a></li><li><a href=https://wizardofmenlo.github.io/tags/polynomial-commitments/>polynomial-commitments</a></li><li><a href=https://wizardofmenlo.github.io/tags/theory/>theory</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>