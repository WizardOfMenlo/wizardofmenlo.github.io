<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions | Giacomo's Blog</title>
<meta name=keywords content="lattices,polynomial-commitments"><meta name=description content="In this paper, we construct a succinct polynomial commitment scheme from standard assumptions."><meta name=author content="M.R. Albrecht, G. Fenzi, N.K. Nguyen, O. Lapiha"><link rel=canonical href=https://wizardofmenlo.github.io/papers/slap/><link crossorigin=anonymous href=/assets/css/stylesheet.e6a5e88e2db154a472506061adb422506c68763f439560b2fdaea2816aecdbd6.css integrity="sha256-5qXoji2xVKRyUGBhrbQiUGxodj9DlWCy/a6igWrs29Y=" rel="preload stylesheet" as=style><link rel=icon href=https://wizardofmenlo.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizardofmenlo.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizardofmenlo.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wizardofmenlo.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions"><meta property="og:description" content="In this paper, we construct a succinct polynomial commitment scheme from standard assumptions."><meta property="og:type" content="article"><meta property="og:url" content="https://wizardofmenlo.github.io/papers/slap/"><meta property="article:section" content="papers"><meta property="article:published_time" content="2023-09-25T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions"><meta name=twitter:description content="In this paper, we construct a succinct polynomial commitment scheme from standard assumptions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Papers","item":"https://wizardofmenlo.github.io/papers/"},{"@type":"ListItem","position":2,"name":"SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions","item":"https://wizardofmenlo.github.io/papers/slap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions","name":"SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions","description":"In this paper, we construct a succinct polynomial commitment scheme from standard assumptions.","keywords":["lattices","polynomial-commitments"],"articleBody":"This blog-post is a short introduction to our new work: “SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions”. This is joint work with Martin Albrecht, Oleksandra Lapiha and Ngoc Khanh Nguyen, and the full version is available on eprint . Here are also some slides that might be helpful.\nIn our previous paper , we looked at the problem of constructing efficient lattice-based polynomial commitments, to be used in as a drop-in replacement to non-post-quantum secure schemes such as KZG. In doing so we constructed two schemes making use of the techniques in [WW23]1 to obtain succinct verification and extractability. The schemes that we came up two came with a number of caveats namely:\na common reference string of quadratic size in the degree of the polynomial to commit reliance on a non-standard assumption: powerBASIS. one of our schemes achieves polylogarithmic verification time, but has non-negligible (inverse polynomial) soundness error. the other scheme instead has negligible soundness error, but only quasi-polylogarithmic verification time. In this work, we address all of these issues and obtain a lattice-based polynomial commitment scheme with:\npolylogarithmic common reference string size quasi-linear commitment time polylogarithmic verification time negligible soundness error (without parallel repetition) security that reduces to the hardness of Module-SIS, a standard lattice assumption. Roadmap Refer to the previous blog post for a refresher on polynomial commitment schemes and more.\nConstruction of a polynomial commitment scheme is a two-step process:\nConstruction of a commitment scheme Designing of a proof system for the statement “$f(u) = z$ and $\\mathbf{t}$ is a commitment to $f$”. We take a brief look at both of these steps.\nMerkle-PRISIS commitment In order to achieve succinct verification, we require that the first commitment is compressing. Further, we would like the scheme to be binding for arbitrary vectors in $\\mathcal{R}_q$.\nOur starting point is a “toy” 2-to-1 commitment scheme. Below, for some fixed $w, \\mathbf{A}$, and denoting by $\\mathbf{G}$ the “gadget matrix” let $$ \\mathbf{B} = \\begin{bmatrix} \\mathbf{A} \u0026 \u0026 - \\mathbf{G} \\\\ \u0026 w\\mathbf{A}\u0026 -\\mathbf{G} \\end{bmatrix} \\enspace. $$\n$\\mathsf{Setup}(1^\\lambda) \\to (\\mathsf{pk}, \\mathsf{vk})$ samples $\\mathbf{A}, w$ and uses [MP12]2 sampling to construct a trapdoor $\\mathbf{T}$ of $\\mathbf{B}$. The verification key consists of $\\mathbf{A}, \\mathbf{W}$ and the proving key additionally contains $\\mathbf{T}$. $\\mathsf{Com}(\\mathsf{pk}, f_0, f_1) \\to (\\sigma, \\mathsf{aux})$ sets $\\mathbf{t}_b := f_b \\cdot \\mathbf{e}_1$. It then uses $\\mathbf{T}$ to sample short $\\mathbf{s}_0, \\mathbf{s}_1$ and $\\hat{\\mathbf{t}}$ such that $\\mathbf{B}[\\mathbf{s}_0, \\mathbf{s}_1, \\hat{\\mathbf{t}}]^\\top = [-\\mathbf{t}_0, -\\mathbf{t}_1]^\\top$, it then outputs $\\mathbf{t} := \\mathbf{G}\\hat{\\mathbf{t}}$ and $(\\mathbf{s}_b)_b$ as decommitment. $\\mathsf{Open}(\\mathsf{vk}, f, \\sigma, \\mathsf{aux})$ checks that the openings are indeed short, and that the equations are all satisfied: namely it checks that, for $b \\in \\{0,1\\}$, $$w^b \\mathbf{A}\\mathbf{s}_b + \\mathbf{t} = \\mathbf{t}_b \\enspace.$$ This scheme is binding under a 2-arity version of the PRISIS assumption introduced in our previous work, which we had shown to Module-SIS! With this observation, the natural next step is to use this “toy” scheme recursively, and construct a “Merkle tree”-like structure. To do so, we sample a matrix and a trapdoor for each layer of the tree, and commit to the commitments originating for the bottom layer. Note that this achieves already the efficiency goals that we had set for ourselves, as building a Merkle tree only requires a linear number of invokations of the inner commitment scheme. Does this overall scheme satisfy the binding property? Well, in fact if you look at the commitment that is used in the inner nodes of the tree, that is not by itself binding. However, we show that the overall construction is binding under a multi-instance version of the PRISIS assumption of arity 2! We then provide a reduction of this multi-instance assumption to the single instance version, which combined with our previous observation reduces binding to Module-SIS. We further show a direct tighter reduction from multi-instance arity 2 PRISIS to Module-SIS, which we use for parameters later on.\nEvaluation protocol The evaluation protocol that we design is conceptually very similar to the one that we developed in our previous work. We take inspiration from FRI and Bulletproofs. In each round of the protocol, the prover splits the polynomial in $2^k$ components (when $k=1$, components correspond to the odd and even coefficients). It sends evaluations of these polynomials and partial opening corresponding to the $k$-th layer of the tree. and receives randomness from the verifier, that it uses to compute a new polynomial, of degree roughly $d/2^k$, that corresponds to the random linear combination of those components. Prover and verifier then can efficiently update the common reference string, instance and witness and recurse on the claim.\nBy itself, this protocol achieves polylogarithmic verifier and communication complexity, but inherits many of the drawbacks of the previous protocol, namely the inverse polynomial soundness error. To improve, while avoiding parallel repetition, we make use of the techniques of [BHRRS21]3, combined with the amortization techniques that we had talked about in our previous work. Our new protocol (as our old) has efficient proof aggregation, in the sense that proving many statements of the form $\\{ f_i(u) = z_i \\}_{i \\in [r]}$ has cost roughly equivalent to proving a single claim. To amplify soundness, we prove the same claim multiple times, and use the aggregation techniques in order to mantain efficiency. An appropriate setting of parameters then enables us to have an evaluation protocol that has polylogarithmic verifier and communication complexity, and negligible knowledge soundness error. In particular, this means that we can compile the protocol to a non-interactive argument using the Fiat-Shamir transform, and achieve a sound non-interactive polynomial commitment scheme with polylogarithmic proof sizes, common reference string, and quasi-linear time prover.\nThe scheme here presented is for proving evaluations of polynomials over polynomial rings, while most uses of polynomial commitments in the wild are concerned with finite fields. While we could make use of the techniques in the previous work to obtain such a scheme, we also present a new generic transformation that could be of independent interest.\nInstantiations We performed an evaluation of the concrete efficiency of our scheme, details of which you can find in the full version. Concretely, proof sizes for a polynomial of degree $d = 2^{20}$ are around 36 MB, which makes the scheme concretely inefficient. Some of these inefficiencies are inherent in the [MP12]2 trapdoor sampling techniques that we make use of, some from the high number of repetitions that our techniques require. Reaching concrete efficiency is left for, ambitious, future work.\nCitation M. R. Albrecht, G. Fenzi, O. Lapiha, N. K. Nguyen. “SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions”. Cryptology ePrint Archive, Paper 2023/1469. Available at: https://ia.cr/2023/1469 .\n@misc{AFNL23, author = {Martin R. Albrecht and Giacomo Fenzi and Ngoc Khanh Nguyen and Oleksandra Lapiha}, title = {SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions}, howpublished = {Cryptology ePrint Archive, Paper 2023/1469}, year = {2023}, note = {\\url{https://eprint.iacr.org/2023/1469}, url = {https://eprint.iacr.org/2023/1469} } Related material H. Wee and D. J. Wu. “Succinct Vector, Polynomial, and Functional Commitments from Lattices”. In: EUROCRYPT (3). Vol. 14006. Lecture Notes in Computer Science. Full version: https://eprint.iacr.org/2022/1515 . Springer, 2023, pp. 385–416. ↩︎\nD. Micciancio and C. Peikert. “Trapdoors for Lattices: Simpler, Tighter, Faster, Smaller”. In: EUROCRYPT. 2012, pp. 700–718. ↩︎ ↩︎\nAlexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. “Time and Space-Efficient Arguments from Groups of Unknown Order”. In: CRYPTO 2021. Lecture Notes in Computer Science. Heidelberg, 2021, pp. 123–152. ↩︎\n","wordCount":"1223","inLanguage":"en","datePublished":"2023-09-25T00:00:00Z","dateModified":"2023-09-25T00:00:00Z","author":{"@type":"Person","name":"M.R. Albrecht, G. Fenzi, N.K. Nguyen, O. Lapiha"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizardofmenlo.github.io/papers/slap/"},"publisher":{"@type":"Organization","name":"Giacomo's Blog","logo":{"@type":"ImageObject","url":"https://wizardofmenlo.github.io/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-183HXT3DZB"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-183HXT3DZB")</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\begin{equation}",right:"\\end{equation}",display:!0},{left:"\\begin{equation*}",right:"\\end{equation*}",display:!0},{left:"\\begin{align}",right:"\\end{align}",display:!0},{left:"\\begin{align*}",right:"\\end{align*}",display:!0},{left:"\\begin{alignat}",right:"\\end{alignat}",display:!0},{left:"\\begin{gather}",right:"\\end{gather}",display:!0},{left:"\\begin{CD}",right:"\\end{CD}",display:!0}],throwOnError:!1})})</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://wizardofmenlo.github.io/ accesskey=h title="Giacomo Fenzi"><img src=https://wizardofmenlo.github.io/favicon.ico alt aria-label=logo height=18 width=18>Giacomo Fenzi</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://wizardofmenlo.github.io/about title=About><span>About</span></a></li><li><a href=https://wizardofmenlo.github.io/papers/ title=Papers><span>Papers</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions</h1><div class=post-meta>&lt;span title='2023-09-25 00:00:00 +0000 UTC'>September 2023&lt;/span>&amp;nbsp;&amp;middot;&amp;nbsp;M.R. Albrecht, G. Fenzi, N.K. Nguyen, O. Lapiha&nbsp;&#183;&nbsp;<a href=https://eprint.iacr.org/2023/1469 rel="noopener noreferrer" target=_blank>ePrint: 2023/1469</a></div></header><div class=post-content><p>This blog-post is a short introduction to our new work: &ldquo;SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions&rdquo;. This is joint work with Martin Albrecht, Oleksandra Lapiha and Ngoc Khanh Nguyen, and the full version is <a href=https://eprint.iacr.org/2023/1469 target=_blank>available on eprint</a>
. Here are also <a href=/presentations/slap.pdf>some slides</a>
that might be helpful.</p><p>In our <a href=https://wizardofmenlo.github.io/papers/towards-pcs/>previous paper</a>
, we looked at the problem of constructing efficient lattice-based polynomial commitments, to be used in as a drop-in replacement to non-post-quantum secure schemes such as KZG.
In doing so we constructed two schemes making use of the techniques in [WW23]<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> to obtain succinct verification and extractability. The schemes that we came up two came with a number of caveats namely:</p><ul><li>a common reference string of quadratic size in the degree of the polynomial to commit</li><li>reliance on a non-standard assumption: powerBASIS.</li><li>one of our schemes achieves polylogarithmic verification time, but has non-negligible (inverse polynomial) soundness error.</li><li>the other scheme instead has negligible soundness error, but only quasi-polylogarithmic verification time.</li></ul><p>In this work, we address all of these issues and obtain a lattice-based polynomial commitment scheme with:</p><ul><li>polylogarithmic common reference string size</li><li>quasi-linear commitment time</li><li>polylogarithmic verification time</li><li>negligible soundness error (without parallel repetition)</li><li>security that reduces to the hardness of Module-SIS, a standard lattice assumption.</li></ul><hr><h2 id=roadmap>Roadmap</h2><p>Refer to the <a href=https://wizardofmenlo.github.io/papers/towards-pcs/>previous blog post</a>
for a refresher on polynomial commitment schemes and more.</p><p>Construction of a polynomial commitment scheme is a two-step process:</p><ol><li>Construction of a commitment scheme</li><li>Designing of a proof system for the statement &ldquo;$f(u) = z$ and $\mathbf{t}$ is a commitment to $f$&rdquo;.</li></ol><p>We take a brief look at both of these steps.</p><hr><h2 id=merkle-prisis-commitment>Merkle-PRISIS commitment</h2><p>In order to achieve succinct verification, we require that the first commitment is <em>compressing</em>. Further, we would like the scheme to be binding for <em>arbitrary</em> vectors in $\mathcal{R}_q$.</p><p>Our starting point is a &ldquo;toy&rdquo; 2-to-1 commitment scheme. Below, for some fixed $w, \mathbf{A}$, and denoting by $\mathbf{G}$ the &ldquo;gadget matrix&rdquo; let
$$
\mathbf{B} = \begin{bmatrix} \mathbf{A} & & - \mathbf{G} \\ & w\mathbf{A}& -\mathbf{G} \end{bmatrix} \enspace.
$$</p><ul><li>$\mathsf{Setup}(1^\lambda) \to (\mathsf{pk}, \mathsf{vk})$ samples $\mathbf{A}, w$ and uses [MP12]<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> sampling to construct a trapdoor $\mathbf{T}$ of $\mathbf{B}$. The verification key consists of $\mathbf{A}, \mathbf{W}$ and the proving key additionally contains $\mathbf{T}$.</li><li>$\mathsf{Com}(\mathsf{pk}, f_0, f_1) \to (\sigma, \mathsf{aux})$ sets $\mathbf{t}_b := f_b \cdot \mathbf{e}_1$. It then uses $\mathbf{T}$ to sample short $\mathbf{s}_0, \mathbf{s}_1$ and $\hat{\mathbf{t}}$ such that $\mathbf{B}[\mathbf{s}_0, \mathbf{s}_1, \hat{\mathbf{t}}]^\top = [-\mathbf{t}_0, -\mathbf{t}_1]^\top$, it then outputs $\mathbf{t} := \mathbf{G}\hat{\mathbf{t}}$ and $(\mathbf{s}_b)_b$ as decommitment.</li><li>$\mathsf{Open}(\mathsf{vk}, f, \sigma, \mathsf{aux})$ checks that the openings are indeed short, and that the equations are all satisfied: namely it checks that, for $b \in \{0,1\}$, $$w^b \mathbf{A}\mathbf{s}_b + \mathbf{t} = \mathbf{t}_b \enspace.$$</li></ul><p>This scheme is binding under a 2-arity version of the PRISIS assumption introduced in our previous work, which we had shown to Module-SIS!
With this observation, the natural next step is to use this &ldquo;toy&rdquo; scheme recursively, and construct a &ldquo;Merkle tree&rdquo;-like structure.
To do so, we sample a matrix and a trapdoor for <em>each layer</em> of the tree, and commit to the commitments originating for the bottom layer. Note that this achieves already the efficiency goals that we had set for ourselves, as building a Merkle tree only requires a linear number of invokations of the inner commitment scheme.
Does this overall scheme satisfy the binding property? Well, in fact if you look at the commitment that is used in the inner nodes of the tree, that is <em>not</em> by itself binding. However, we show that the overall construction is binding under a multi-instance version of the PRISIS assumption of arity 2!
We then provide a reduction of this multi-instance assumption to the single instance version, which combined with our previous observation reduces binding to Module-SIS. We further show a direct tighter reduction from multi-instance arity 2 PRISIS to Module-SIS, which we use for parameters later on.</p><hr><h2 id=evaluation-protocol>Evaluation protocol</h2><p>The evaluation protocol that we design is conceptually very similar to the one that we developed in our previous work. We take inspiration from FRI and Bulletproofs. In each round of the protocol, the prover splits the polynomial in $2^k$ components (when $k=1$, components correspond to the odd and even coefficients). It sends evaluations of these polynomials and <em>partial opening</em> corresponding to the $k$-th layer of the tree.
and receives randomness from the verifier, that it uses to compute a new polynomial, of degree roughly $d/2^k$, that corresponds to the random linear combination of those components. Prover and verifier then can efficiently update the common reference string, instance and witness and recurse on the claim.</p><p>By itself, this protocol achieves polylogarithmic verifier and communication complexity, but inherits many of the drawbacks of the previous protocol, namely the inverse polynomial soundness error. To improve, while avoiding parallel repetition, we make use of the techniques of [BHRRS21]<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, combined with the amortization techniques that we had talked about in our previous work. Our new protocol (as our old) has efficient proof aggregation, in the sense that proving many statements of the form $\{ f_i(u) = z_i \}_{i \in [r]}$ has cost roughly equivalent to proving a single claim. To amplify soundness, we prove the same claim multiple times, and use the aggregation techniques in order to mantain efficiency. An appropriate setting of parameters then enables us to have an evaluation protocol that has polylogarithmic verifier and communication complexity, and negligible knowledge soundness error.
In particular, this means that we can compile the protocol to a non-interactive argument using the Fiat-Shamir transform, and achieve a sound non-interactive polynomial commitment scheme with polylogarithmic proof sizes, common reference string, and quasi-linear time prover.</p><p>The scheme here presented is for proving evaluations of polynomials over polynomial rings, while most uses of polynomial commitments in the wild are concerned with finite fields. While we could make use of the techniques in the previous work to obtain such a scheme, we also present a new generic transformation that could be of independent interest.</p><hr><h2 id=instantiations>Instantiations</h2><p>We performed an evaluation of the concrete efficiency of our scheme, details of which you can find in the full version. Concretely, proof sizes for a polynomial of degree $d = 2^{20}$ are around 36 MB, which makes the scheme concretely inefficient. Some of these inefficiencies are inherent in the [MP12]<sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> trapdoor sampling techniques that we make use of, some from the high number of repetitions that our techniques require. Reaching concrete efficiency is left for, ambitious, future work.</p><hr><h5 id=citation>Citation</h5><p>M. R. Albrecht, G. Fenzi, O. Lapiha, N. K. Nguyen. &ldquo;<em>SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions</em>&rdquo;. Cryptology ePrint Archive, Paper 2023/1469. Available at: <a href=https://ia.cr/2023/1469 target=_blank>https://ia.cr/2023/1469</a>
.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-BibTeX data-lang=BibTeX><span style=display:flex><span><span style=color:#0a0;text-decoration:underline>@misc</span>{AFNL23,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>author</span> = <span style=color:#a50>{Martin R. Albrecht and Giacomo Fenzi and Ngoc Khanh Nguyen and Oleksandra Lapiha}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>title</span> = <span style=color:#a50>{SLAP: Succinct Lattice-Based Polynomial Commitments from Standard Assumptions}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>howpublished</span> = <span style=color:#a50>{Cryptology ePrint Archive, Paper 2023/1469}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>year</span> = <span style=color:#a50>{2023}</span>,
</span></span><span style=display:flex><span>	<span style=color:#1e90ff>note</span> = <span style=color:#a50>{\url{https://eprint.iacr.org/2023/1469},
</span></span></span><span style=display:flex><span><span style=color:#a50>	url = {https://eprint.iacr.org/2023/1469}
</span></span></span><span style=display:flex><span><span style=color:#a50>}</span>
</span></span></code></pre></div><hr><h5 id=related-material>Related material</h5><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>H. Wee and D. J. Wu. &ldquo;Succinct Vector, Polynomial, and Functional Commitments from Lattices&rdquo;. In: EUROCRYPT (3). Vol. 14006. Lecture Notes in Computer Science. Full version: <a href=https://eprint.iacr.org/2022/1515 target=_blank>https://eprint.iacr.org/2022/1515</a>
. Springer, 2023, pp. 385–416.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>D. Micciancio and C. Peikert. &ldquo;Trapdoors for Lattices: Simpler, Tighter, Faster, Smaller&rdquo;. In: EUROCRYPT. 2012, pp. 700–718.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. &ldquo;Time and Space-Efficient Arguments from Groups of Unknown Order&rdquo;. In: CRYPTO 2021. Lecture Notes in Computer Science. Heidelberg, 2021, pp. 123–152.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizardofmenlo.github.io/tags/lattices/>lattices</a></li><li><a href=https://wizardofmenlo.github.io/tags/polynomial-commitments/>polynomial-commitments</a></li></ul></footer></article></main><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>